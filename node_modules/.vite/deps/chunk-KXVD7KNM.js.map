{
  "version": 3,
  "sources": ["../../base64-js/index.js", "../../ieee754/index.js", "../../buffer/index.js", "../../safe-buffer/index.js", "../../string_decoder/lib/string_decoder.js", "browser-external:fs", "../../../../tfjs-data/src/index.ts", "../../../../tfjs-data/src/dataset.ts", "../../../../tfjs-data/src/iterators/lazy_iterator.ts", "../../../../tfjs-data/src/util/deep_map.ts", "../../../../tfjs-data/src/util/deep_clone.ts", "../../../../tfjs-data/src/util/ring_buffer.ts", "../../../../tfjs-data/src/util/growing_ring_buffer.ts", "../../../../tfjs-data/src/datasets/text_line_dataset.ts", "../../../../tfjs-data/src/datasets/csv_dataset.ts", "../../../../tfjs-data/src/iterators/microphone_iterator.ts", "../../../../tfjs-data/src/iterators/webcam_iterator.ts", "../../../../tfjs-data/src/datasource.ts", "../../../../tfjs-data/src/iterators/string_iterator.ts", "../../../../tfjs-data/src/iterators/byte_chunk_iterator.ts", "../../../../tfjs-data/src/iterators/file_chunk_iterator.ts", "../../../../tfjs-data/src/iterators/url_chunk_iterator.ts", "../../../../tfjs-data/src/util/source_util.ts", "../../../../tfjs-data/src/sources/file_data_source.ts", "../../../../tfjs-data/src/sources/url_data_source.ts", "../../../../tfjs-data/src/readers.ts", "../../../../tfjs-data/src/version.ts"],
  "sourcesContent": ["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n", "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n", "/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"fs\" has been externalized for browser compatibility. Cannot access \"fs.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport {array, Dataset, zip} from './dataset';\nexport {CSVDataset} from './datasets/csv_dataset';\nexport {TextLineDataset} from './datasets/text_line_dataset';\nexport {csv, func, generator, microphone, webcam} from './readers';\nexport {FileDataSource} from './sources/file_data_source';\nexport {URLDataSource} from './sources/url_data_source';\nexport {ColumnConfig, MicrophoneConfig, WebcamConfig} from './types';\nexport {version as version_data} from './version';\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {TensorContainer, TensorLike} from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\n\nimport {iteratorFromConcatenated, iteratorFromFunction, iteratorFromItems, iteratorFromZipped, LazyIterator, ZipMismatchMode} from './iterators/lazy_iterator';\nimport {Container} from './types';\nimport {canTensorify, deepMapAndAwaitAll, DeepMapResult, isIterable} from './util/deep_map';\n\n/**\n * A nested structure of Datasets, used as the input to zip().\n */\nexport type DatasetContainer = Container<Dataset<TensorContainer>>;\n\n// TODO(soergel): consider vectorized operations within the pipeline.\n\n/**\n * Represents a potentially large list of independent data elements (typically\n * 'samples' or 'examples').\n *\n * A 'data example' may be a primitive, an array, a map from string keys to\n * values, or any nested structure of these.\n *\n * A `Dataset` represents an ordered collection of elements, together with a\n * chain of transformations to be performed on those elements. Each\n * transformation is a method of `Dataset` that returns another `Dataset`, so\n * these may be chained, e.g.\n * `const processedDataset = rawDataset.filter(...).map(...).batch(...)`.\n *\n * Data loading and transformation is done in a lazy, streaming fashion.  The\n * dataset may be iterated over multiple times; each iteration starts the data\n * loading anew and recapitulates the transformations.\n *\n * A `Dataset` is typically processed as a stream of unbatched examples -- i.e.,\n * its transformations are applied one example at a time. Batching produces a\n * new `Dataset` where each element is a batch. Batching should usually come\n * last in a pipeline, because data transformations are easier to express on a\n * per-example basis than on a per-batch basis.\n *\n * The following code examples are calling `await dataset.forEachAsync(...)` to\n * iterate once over the entire dataset in order to print out the data.\n *\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\n */\nexport abstract class Dataset<T extends tf.TensorContainer> {\n  /*\n   * Provide a new stream of elements.  Note this will also start new streams\n   * from any underlying `Dataset`s.\n   *\n   * CAUTION: Any Tensors contained within the elements returned from\n   * this stream *must* be manually disposed to avoid a GPU memory leak.\n   * The tf.tidy() approach cannot be used in an asynchronous context.\n   */\n  abstract async iterator(): Promise<LazyIterator<T>>;\n\n  readonly size: number = null;\n\n  // TODO(soergel): Make Datasets report whether repeated iterator() calls\n  // produce the same result (e.g., reading from a file) or different results\n  // (e.g., from the webcam).  Currently we don't make this distinction but it\n  // could be important for the user to know.\n  // abstract isDeterministic(): boolean;\n\n  /**\n   * Groups elements into batches.\n   *\n   * It is assumed that each of the incoming dataset elements has the same\n   * structure -- i.e. the same set of keys at each location in an object\n   * hierarchy.  For each key, the resulting `Dataset` provides a batched\n   * element collecting all of the incoming values for that key.\n   *\n   *  * Incoming primitives are grouped into a 1-D Tensor.\n   *  * Incoming Tensors are grouped into a new Tensor where the 0th axis is\n   *    the batch dimension.\n   *  * Incoming arrays are converted to Tensor and then batched.\n   *  * A nested array is interpreted as an n-D Tensor, so the batched result\n   *    has n+1 dimensions.\n   *  * An array that cannot be converted to Tensor produces an error.\n   *\n   * If an array should not be batched as a unit, it should first be converted\n   * to an object with integer keys.\n   *\n   * Here are a few examples:\n   *\n   * Batch a dataset of numbers:\n   * ```js\n   * const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8]).batch(4);\n   * await a.forEachAsync(e => e.print());\n   * ```\n   *\n   * Batch a dataset of arrays:\n   * ```js\n   * const b = tf.data.array([[1], [2], [3], [4], [5], [6], [7], [8]]).batch(4);\n   * await b.forEachAsync(e => e.print());\n   * ```\n   *\n   * Batch a dataset of objects:\n   * ```js\n   * const c = tf.data.array([{a: 1, b: 11}, {a: 2, b: 12}, {a: 3, b: 13},\n   *   {a: 4, b: 14}, {a: 5, b: 15}, {a: 6, b: 16}, {a: 7, b: 17},\n   *   {a: 8, b: 18}]).batch(4);\n   * await c.forEachAsync(e => {\n   *   console.log('{');\n   *   for(var key in e) {\n   *     console.log(key+':');\n   *     e[key].print();\n   *   }\n   *   console.log('}');\n   * })\n   * ```\n   *\n   * @param batchSize The number of elements desired per batch.\n   * @param smallLastBatch Whether to emit the final batch when it has fewer\n   *   than batchSize elements. Default true.\n   * @returns A `Dataset`, from which a stream of batches can be obtained.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  batch(batchSize: number, smallLastBatch = true): Dataset<tf.TensorContainer> {\n    const base = this;\n    tf.util.assert(\n        batchSize > 0, () => `batchSize needs to be positive, but it is\n      ${batchSize}`);\n    let size;\n    if (this.size === Infinity || this.size == null) {\n      // If the size of this dataset is infinity or null, the new size keeps the\n      // same.\n      size = this.size;\n    } else if (smallLastBatch) {\n      // If the size of this dataset is known and include small last batch, the\n      // new size is full batch count plus last batch.\n      size = Math.ceil(this.size / batchSize);\n    } else {\n      // If the size of this dataset is known and not include small last batch,\n      // the new size is full batch count.\n      size = Math.floor(this.size / batchSize);\n    }\n    return datasetFromIteratorFn(async () => {\n      return (await base.iterator())\n          .columnMajorBatch(batchSize, smallLastBatch, deepBatchConcat);\n    }, size);\n  }\n\n  /**\n   * Concatenates this `Dataset` with another.\n   *\n   * ```js\n   * const a = tf.data.array([1, 2, 3]);\n   * const b = tf.data.array([4, 5, 6]);\n   * const c = a.concatenate(b);\n   * await c.forEachAsync(e => console.log(e));\n   * ```\n   *\n   * @param dataset A `Dataset` to be concatenated onto this one.\n   * @returns A `Dataset`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  concatenate(dataset: Dataset<T>): Dataset<T> {\n    const base = this;\n    let size;\n    if (this.size === Infinity || dataset.size === Infinity) {\n      // If the size of any of these two dataset is infinity, new size is\n      // infinity.\n      size = Infinity;\n    } else if (this.size != null && dataset.size != null) {\n      // If the size of both datasets are known and not infinity, new size is\n      // sum the size of these two datasets.\n      size = this.size + dataset.size;\n    } else {\n      // If neither of these two datasets has infinite size and any of these two\n      // datasets' size is null, the new size is null.\n      size = null;\n    }\n    return datasetFromIteratorFn(\n        async () =>\n            (await base.iterator()).concatenate(await dataset.iterator()),\n        size);\n  }\n\n  /**\n   * Filters this dataset according to `predicate`.\n   *\n   * ```js\n   * const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n   *   .filter(x => x%2 === 0);\n   * await a.forEachAsync(e => console.log(e));\n   * ```\n   *\n   * @param predicate A function mapping a dataset element to a boolean or a\n   * `Promise` for one.\n   *\n   * @returns A `Dataset` of elements for which the predicate was true.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  filter(predicate: (value: T) => boolean): Dataset<T> {\n    const base = this;\n    let size;\n    if (this.size === Infinity) {\n      // If the size of this dataset is infinity, new size is infinity\n      size = Infinity;\n    } else {\n      // If this dataset has limited elements, new size is null because it might\n      // exhausted randomly.\n      size = null;\n    }\n    return datasetFromIteratorFn(async () => {\n      return (await base.iterator()).filter(x => tf.tidy(() => predicate(x)));\n    }, size);\n  }\n\n  /**\n   * Apply a function to every element of the dataset.\n   *\n   * After the function is applied to a dataset element, any Tensors contained\n   * within that element are disposed.\n   *\n   * ```js\n   * const a = tf.data.array([1, 2, 3]);\n   * await a.forEachAsync(e => console.log(e));\n   * ```\n   *\n   * @param f A function to apply to each dataset element.\n   * @returns A `Promise` that resolves after all elements have been processed.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  async forEachAsync(f: (input: T) => void): Promise<void> {\n    return (await this.iterator()).forEachAsync(f);\n  }\n\n  /**\n   * Maps this dataset through a 1-to-1 transform.\n   *\n   * ```js\n   * const a = tf.data.array([1, 2, 3]).map(x => x*x);\n   * await a.forEachAsync(e => console.log(e));\n   * ```\n   *\n   * @param transform A function mapping a dataset element to a transformed\n   *   dataset element.\n   *\n   * @returns A `Dataset` of transformed elements.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  map<O extends tf.TensorContainer>(transform: (value: T) => O): Dataset<O> {\n    const base = this;\n    return datasetFromIteratorFn(async () => {\n      return (await base.iterator()).map(x => tf.tidy(() => transform(x)));\n    }, this.size);\n  }\n\n  /**\n   * Maps this dataset through an async 1-to-1 transform.\n   *\n   * ```js\n   * const a =\n   *  tf.data.array([1, 2, 3]).mapAsync(x => new Promise(function(resolve){\n   *    setTimeout(() => {\n   *      resolve(x * x);\n   *    }, Math.random()*1000 + 500);\n   *  }));\n   * console.log(await a.toArray());\n   * ```\n   *\n   * @param transform A function mapping a dataset element to a `Promise` for a\n   *   transformed dataset element.  This transform is responsible for disposing\n   *   any intermediate `Tensor`s, i.e. by wrapping its computation in\n   *   `tf.tidy()`; that cannot be automated here (as it is in the synchronous\n   *   `map()` case).\n   *\n   * @returns A `Dataset` of transformed elements.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  mapAsync<O extends tf.TensorContainer>(transform: (value: T) => Promise<O>):\n      Dataset<O> {\n    const base = this;\n    return datasetFromIteratorFn(async () => {\n      return (await base.iterator()).mapAsync(transform);\n    }, this.size);\n  }\n\n  /**\n   *  Creates a `Dataset` that prefetches elements from this dataset.\n   *\n   * @param bufferSize: An integer specifying the number of elements to be\n   *   prefetched.\n   * @returns A `Dataset`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  prefetch(bufferSize: number): Dataset<T> {\n    if (bufferSize == null) {\n      throw new RangeError(\n          '`Dataset.prefetch()` requires bufferSize to be specified.');\n    }\n\n    const base = this;\n    return datasetFromIteratorFn(\n        async () => (await base.iterator()).prefetch(bufferSize), this.size);\n  }\n\n  /**\n   * Repeats this dataset `count` times.\n   *\n   * NOTE: If this dataset is a function of global state (e.g. a random number\n   * generator), then different repetitions may produce different elements.\n   *\n   * ```js\n   * const a = tf.data.array([1, 2, 3]).repeat(3);\n   * await a.forEachAsync(e => console.log(e));\n   * ```\n   *\n   * @param count: (Optional) An integer, representing the number of times\n   *   the dataset should be repeated. The default behavior (if `count` is\n   *   `undefined` or negative) is for the dataset be repeated indefinitely.\n   * @returns A `Dataset`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  repeat(count?: number): Dataset<T> {\n    const base = this;\n    let size;\n    if (this.size != null && count > 0) {\n      // If this dataset has size and count is positive, new size is current\n      // size multiply count. This also covers the case that current size is\n      // infinity.\n      size = this.size * count;\n    } else if (count === 0) {\n      // If count is 0, new size is 0.\n      size = 0;\n    } else if (this.size != null && (count === undefined || count < 0)) {\n      // If this dataset has size and count is undefined or negative, the\n      // dataset will be repeated indefinitely and new size is infinity.\n      size = Infinity;\n    } else {\n      // If the size of this dataset is null, the new dataset's size is null.\n      size = null;\n    }\n    return datasetFromIteratorFn(async () => {\n      const iteratorIterator = iteratorFromFunction(\n          async () => ({value: await base.iterator(), done: false}));\n      return iteratorFromConcatenated(iteratorIterator.take(count));\n    }, size);\n  }\n\n  /**\n   * Creates a `Dataset` that skips `count` initial elements from this dataset.\n   *\n   * ```js\n   * const a = tf.data.array([1, 2, 3, 4, 5, 6]).skip(3);\n   * await a.forEachAsync(e => console.log(e));\n   * ```\n   *\n   * @param count: The number of elements of this dataset that should be skipped\n   *   to form the new dataset.  If `count` is greater than the size of this\n   *   dataset, the new dataset will contain no elements.  If `count`\n   *   is `undefined` or negative, skips the entire dataset.\n   *\n   * @returns A `Dataset`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  skip(count: number): Dataset<T> {\n    const base = this;\n    let size;\n    if (this.size != null && count >= 0 && this.size >= count) {\n      // If the size of this dataset is greater than count, the new dataset's\n      // size is current size minus skipped size.This also covers the case that\n      // current size is infinity.\n      size = this.size - count;\n    } else if (\n        this.size != null &&\n        (this.size < count || count === undefined || count < 0)) {\n      // If the size of this dataset is smaller than count, or count is\n      // undefined or negative, skips the entire dataset and the new size is 0.\n      size = 0;\n    } else {\n      // If the size of this dataset is null, the new dataset's size is null.\n      size = null;\n    }\n    return datasetFromIteratorFn(\n        async () => (await base.iterator()).skip(count), size);\n  }\n\n  // TODO(soergel): deep sharded shuffle, where supported\n\n  static readonly MAX_BUFFER_SIZE = 10000;\n\n  /**\n   * Pseudorandomly shuffles the elements of this dataset. This is done in a\n   * streaming manner, by sampling from a given number of prefetched elements.\n   *\n   * ```js\n   * const a = tf.data.array([1, 2, 3, 4, 5, 6]).shuffle(3);\n   * await a.forEachAsync(e => console.log(e));\n   * ```\n   *\n   * @param bufferSize: An integer specifying the number of elements from this\n   *   dataset from which the new dataset will sample.\n   * @param seed: (Optional) An integer specifying the random seed that will\n   *   be used to create the distribution.\n   * @param reshuffleEachIteration: (Optional) A boolean, which if true\n   *   indicates that the dataset should be pseudorandomly reshuffled each time\n   *   it is iterated over. If false, elements will be returned in the same\n   *   shuffled order on each iteration. (Defaults to `true`.)\n   * @returns A `Dataset`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  shuffle(bufferSize: number, seed?: string, reshuffleEachIteration = true):\n      Dataset<T> {\n    if (bufferSize == null || bufferSize < 0) {\n      if (this.size == null) {\n        throw new RangeError(\n            '`Dataset.shuffle()` requires bufferSize to be specified.');\n      } else {\n        throw new RangeError(\n            '`Dataset.shuffle()` requires bufferSize to be specified.  ' +\n            'If your data fits in main memory (for regular JS objects), ' +\n            'and/or GPU memory (for `tf.Tensor`s), consider setting ' +\n            `bufferSize to the dataset size (${this.size} elements)`);\n      }\n    }\n    const base = this;\n    const random = seedrandom.alea(seed || tf.util.now().toString());\n    return datasetFromIteratorFn(async () => {\n      let seed2 = random.int32();\n      if (reshuffleEachIteration) {\n        seed2 += random.int32();\n      }\n      return (await base.iterator()).shuffle(bufferSize, seed2.toString());\n    }, this.size);\n  }\n\n  /**\n   * Creates a `Dataset` with at most `count` initial elements from this\n   * dataset.\n   *\n   * ```js\n   * const a = tf.data.array([1, 2, 3, 4, 5, 6]).take(3);\n   * await a.forEachAsync(e => console.log(e));\n   * ```\n   *\n   * @param count: The number of elements of this dataset that should be taken\n   *   to form the new dataset.  If `count` is `undefined` or negative, or if\n   *   `count` is greater than the size of this dataset, the new dataset will\n   *   contain all elements of this dataset.\n   * @returns A `Dataset`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  take(count: number): Dataset<T> {\n    const base = this;\n    let size;\n    if (this.size != null && this.size > count) {\n      // If the size of this dataset is greater than count, the new dataset's\n      // size is count.\n      size = count;\n    } else if (this.size != null && this.size <= count) {\n      // If the size of this dataset is equal or smaller than count, the new\n      // dataset's size is the size of this dataset.\n      size = this.size;\n    } else {\n      // If the size of this dataset is null, the new dataset's size is null.\n      size = null;\n    }\n    return datasetFromIteratorFn(\n        async () => (await base.iterator()).take(count), size);\n  }\n\n  /**\n   * Collect all elements of this dataset into an array.\n   *\n   * Obviously this will succeed only for small datasets that fit in memory.\n   * Useful for testing and generally should be avoided if possible.\n   *\n   * ```js\n   * const a = tf.data.array([1, 2, 3, 4, 5, 6]);\n   * console.log(await a.toArray());\n   * ```\n   *\n   * @returns A Promise for an array of elements, which will resolve\n   *   when a new stream has been obtained and fully consumed.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  async toArray() {\n    if (this.size === Infinity) {\n      throw new Error('Can not convert infinite data stream to array.');\n    }\n    return (await this.iterator()).toArray();\n  }\n\n  /**\n   * Collect all elements of this dataset into an array with prefetching 100\n   * elements. This is useful for testing, because the prefetch changes the\n   * order in which the Promises are resolved along the processing pipeline.\n   * This may help expose bugs where results are dependent on the order of\n   * Promise resolution rather than on the logical order of the stream (i.e.,\n   * due to hidden mutable state).\n   *\n   * @returns A Promise for an array of elements, which will resolve\n   *   when a new stream has been obtained and fully consumed.\n   */\n  async toArrayForTest() {\n    if (this.size === Infinity) {\n      throw new Error('Can not convert infinite data stream to array.');\n    }\n    return (await this.iterator()).toArrayForTest();\n  }\n}\n\n/**\n * Create a `Dataset` defined by a provided iterator() function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * const ds = tf.data.datasetFromIteratorFn(iter);\n * await ds.forEachAsync(e => console.log(e));\n * ```\n */\nexport function datasetFromIteratorFn<T extends tf.TensorContainer>(\n    iteratorFn: () => Promise<LazyIterator<T>>,\n    size: number = null): Dataset<T> {\n  return new class extends Dataset<T> {\n    size = size;\n\n    /*\n     * Provide a new stream of elements.  Note this will also start new streams\n     * from any underlying `Dataset`s.\n     */\n    async iterator(): Promise<LazyIterator<T>> {\n      return iteratorFn();\n    }\n  }\n  ();\n}\n\n/**\n * Create a `Dataset` from an array of elements.\n *\n * Create a Dataset from an array of objects:\n * ```js\n * const a = tf.data.array([{'item': 1}, {'item': 2}, {'item': 3}]);\n * await a.forEachAsync(e => console.log(e));\n * ```\n *\n * Create a Dataset from an array of numbers:\n * ```js\n * const a = tf.data.array([4, 5, 6]);\n * await a.forEachAsync(e => console.log(e));\n * ```\n * @param items An array of elements that will be parsed as items in a dataset.\n *\n * @doc {heading: 'Data', subheading: 'Creation', namespace: 'data'}\n */\nexport function array<T extends tf.TensorContainer>(items: T[]): Dataset<T> {\n  return datasetFromIteratorFn(\n      async () => iteratorFromItems(items), items.length);\n}\n\n/**\n * Create a `Dataset` by zipping together an array, dict, or nested\n * structure of `Dataset`s (and perhaps additional constants).\n * The underlying datasets must provide elements in a consistent order such that\n * they correspond.\n *\n * The number of elements in the resulting dataset is the same as the size of\n * the smallest dataset in datasets.\n *\n * The nested structure of the `datasets` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Note this means that, given an array of two datasets that produce dict\n * elements, the result is a dataset that produces elements that are arrays\n * of two dicts:\n *\n * Zip an array of datasets:\n * ```js\n * console.log('Zip two datasets of objects:');\n * const ds1 = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);\n * const ds2 = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);\n * const ds3 = tf.data.zip([ds1, ds2]);\n * await ds3.forEachAsync(e => console.log(JSON.stringify(e)));\n *\n * // If the goal is to merge the dicts in order to produce elements like\n * // {a: ..., b: ...}, this requires a second step such as:\n * console.log('Merge the objects:');\n * const ds4 = ds3.map(x => {return {a: x[0].a, b: x[1].b}});\n * await ds4.forEachAsync(e => console.log(e));\n * ```\n *\n * Zip a dict of datasets:\n * ```js\n * const a = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);\n * const b = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);\n * const c = tf.data.zip({c: a, d: b});\n * await c.forEachAsync(e => console.log(JSON.stringify(e)));\n * ```\n *\n * @doc {heading: 'Data', subheading: 'Operations', namespace: 'data'}\n */\nexport function zip<O extends tf.TensorContainer>(datasets: DatasetContainer):\n    Dataset<O> {\n  // manually type-check the argument for JS users\n  if (!isIterable(datasets)) {\n    throw new Error('The argument to zip() must be an object or array.');\n  }\n  let size;\n  if (Array.isArray(datasets)) {\n    for (let i = 0; i < datasets.length; i++) {\n      size = size == null ? (datasets[i] as Dataset<O>).size :\n                            Math.min(size, (datasets[i] as Dataset<O>).size);\n    }\n  } else if (datasets instanceof Object) {\n    for (const ds in datasets) {\n      size = size == null ? (datasets[ds] as Dataset<O>).size :\n                            Math.min(size, (datasets[ds] as Dataset<O>).size);\n    }\n  }\n  return datasetFromIteratorFn<O>(async () => {\n    const streams = await deepMapAndAwaitAll(datasets, d => {\n      if (d instanceof Dataset) {\n        return {value: d.iterator(), recurse: false};\n      } else if (isIterable(d)) {\n        return {value: null, recurse: true};\n      } else {\n        throw new Error(\n            'Leaves of the structure passed to zip() must be Datasets, ' +\n            'not primitives.');\n      }\n    });\n    return iteratorFromZipped<O>(streams, ZipMismatchMode.SHORTEST);\n  }, size);\n}\n\n/**\n * A zip function for use with deepZip, passed via the columnMajorBatch call.\n *\n * Accepts an array of identically-structured nested elements and either batches\n * them (if they are primitives, numeric arrays, or Tensors) or requests\n * recursion (if not).\n */\n// tslint:disable-next-line:no-any\nfunction deepBatchConcat(rows: any[]): DeepMapResult {\n  if (rows === null) {\n    return null;\n  }\n\n  // use the first item to decide whether to recurse or batch here.\n  const exampleRow = rows[0];\n\n  if (canTensorify(exampleRow)) {\n    // rows is an array of primitives, Tensors, or arrays.  Batch them.\n    const value = batchConcat(rows);\n    return {value, recurse: false};\n  }\n\n  // the example row is an object, so recurse into it.\n  return {value: null, recurse: true};\n}\n\n/**\n * Assembles a list of same-shaped numbers, number arrays, or Tensors\n * into a single new Tensor where axis 0 is the batch dimension.\n */\nfunction batchConcat<T extends(TensorLike | tf.Tensor)>(arrays: T[]):\n    tf.Tensor {\n  if (arrays.length === 0) {\n    // We can't return an empty Tensor because we don't know the element shape.\n    throw new Error('Can\\'t make a batch of zero elements.');\n  }\n\n  if (arrays[0] instanceof tf.Tensor) {\n    // Input is an array of Tensors\n    return tf.stack(arrays as tf.Tensor[]);\n  } else {\n    // Input is a possibly-nested array of numbers.\n    return tf.tensor(arrays as TensorLike);\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\n\nimport {Container} from '../types';\nimport {deepClone} from '../util/deep_clone';\nimport {deepMapAndAwaitAll, DeepMapAsyncResult, DeepMapResult, deepZip, zipToList} from '../util/deep_map';\nimport {GrowingRingBuffer} from '../util/growing_ring_buffer';\nimport {RingBuffer} from '../util/ring_buffer';\n\n/**\n * A nested structure of LazyIterators, used as the input to zip().\n */\nexport type IteratorContainer = Container<LazyIterator<tf.TensorContainer>>;\n\n// Here we implement a simple asynchronous iterator.\n// This lets us avoid using either third-party stream libraries or\n// recent TypeScript language support requiring polyfills.\n\n/**\n * Create a `LazyIterator` from an array of items.\n */\nexport function iteratorFromItems<T>(items: T[]): LazyIterator<T> {\n  return new ArrayIterator(items);\n}\n\n/**\n * Create a `LazyIterator` of incrementing integers.\n */\nexport function iteratorFromIncrementing(start: number): LazyIterator<number> {\n  let i = start;\n  return iteratorFromFunction(() => ({value: i++, done: false}));\n}\n\n/**\n * Create a `LazyIterator` from a function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * await iter.forEachAsync(e => console.log(e));\n * ```\n *\n * @param func A function that produces data on each call.\n */\nexport function iteratorFromFunction<T>(\n    func: () =>\n        IteratorResult<T>| Promise<IteratorResult<T>>): LazyIterator<T> {\n  return new FunctionCallIterator(func);\n}\n\n/**\n * Create a `LazyIterator` by concatenating underlying streams, which are\n * themselves provided as a stream.\n *\n * This can also be thought of as a \"stream flatten\" operation.\n *\n * @param baseIterators A stream of streams to be concatenated.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenated<T>(\n    baseIterators: LazyIterator<LazyIterator<T>>,\n    baseErrorHandler?: (e: Error) => boolean): LazyIterator<T> {\n  return new ChainedIterator(baseIterators, baseErrorHandler);\n}\n\n/**\n * Create a `LazyIterator` by concatenating streams produced by calling a\n * stream-generating function a given number of times.\n *\n * Since a `LazyIterator` is read-once, it cannot be repeated, but this\n * function can be used to achieve a similar effect:\n *\n *   LazyIterator.ofConcatenatedFunction(() => new MyIterator(), 6);\n *\n * @param iteratorFunc: A function that produces a new stream on each call.\n * @param count: The number of times to call the function.\n * @param baseErrorHandler An optional function that can intercept `Error`s\n *   raised during a `next()` call on the base stream.  This function can decide\n *   whether the error should be propagated, whether the error should be\n *   ignored, or whether the base stream should be terminated.\n */\nexport function iteratorFromConcatenatedFunction<T>(\n    iteratorFunc: () => IteratorResult<LazyIterator<T>>, count: number,\n    baseErrorHandler?: (e: Error) => boolean): LazyIterator<T> {\n  return iteratorFromConcatenated(\n      iteratorFromFunction(iteratorFunc).take(count), baseErrorHandler);\n}\n\n/**\n * Create a `LazyIterator` by zipping together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nexport function iteratorFromZipped<O extends tf.TensorContainer>(\n    iterators: IteratorContainer,\n    mismatchMode: ZipMismatchMode = ZipMismatchMode.FAIL): LazyIterator<O> {\n  return new ZipIterator<O>(iterators, mismatchMode);\n}\n\n/**\n * An asynchronous iterator, providing lazy access to a potentially\n * unbounded stream of elements.\n *\n * Iterator can be obtained from a dataset:\n * `const iter = await dataset.iterator();`\n */\nexport abstract class LazyIterator<T> {\n  // This class implements AsyncIterator<T>, but we have not yet set the\n  // TypeScript --downlevelIteration flag to enable that.\n\n  abstract summary(): string;\n\n  /**\n   * Returns a `Promise` for the next element in the stream.\n   *\n   * When an item can be provided successfully, the return value is\n   * `{value:T, done:false}`.\n   *\n   * Calling next() on a closed stream returns `{value:null, done:true}`.\n   */\n  abstract async next(): Promise<IteratorResult<T>>;\n\n  /**\n   * Collect all remaining elements of a bounded stream into an array.\n   * Obviously this will succeed only for small streams that fit in memory.\n   * Useful for testing.\n   *\n   * @returns A Promise for an array of stream elements, which will resolve\n   *   when the stream is exhausted.\n   */\n  async toArray(): Promise<T[]> {\n    const result: T[] = [];\n    let x = await this.next();\n    while (!x.done) {\n      result.push(x.value);\n      x = await this.next();\n    }\n    return result;\n  }\n\n  /**\n   * Collect all elements of this dataset into an array with prefetching 100\n   * elements. This is useful for testing, because the prefetch changes the\n   * order in which the Promises are resolved along the processing pipeline.\n   * This may help expose bugs where results are dependent on the order of\n   * Promise resolution rather than on the logical order of the stream (i.e.,\n   * due to hidden mutable state).\n   *\n   * @returns A Promise for an array of stream elements, which will resolve\n   *   when the stream is exhausted.\n   */\n  async toArrayForTest(): Promise<T[]> {\n    const stream = this.prefetch(100);\n    const result: T[] = [];\n    let x = await stream.next();\n    while (!x.done) {\n      result.push(x.value);\n      x = await stream.next();\n    }\n    return result;\n  }\n\n  /**\n   * Draw items from the stream until it is exhausted.\n   *\n   * This can be useful when the stream has side effects but no output.  In\n   * that case, calling this function guarantees that the stream will be\n   * fully processed.\n   */\n  async resolveFully(): Promise<void> {\n    let x = await this.next();\n    while (!x.done) {\n      x = await this.next();\n    }\n  }\n\n  /**\n   * Draw items from the stream until it is exhausted, or a predicate fails.\n   *\n   * This can be useful when the stream has side effects but no output.  In\n   * that case, calling this function guarantees that the stream will be\n   * fully processed.\n   */\n  async resolveWhile(predicate: (r: T) => boolean): Promise<void> {\n    let x = await this.next();\n    let shouldContinue = predicate(x.value);\n    while ((!x.done) && shouldContinue) {\n      x = await this.next();\n      shouldContinue = predicate(x.value);\n    }\n  }\n\n  /**\n   * Handles errors thrown on this stream using a provided handler function.\n   *\n   * @param handler A function that handles any `Error` thrown during a `next()`\n   *   call and returns true if the stream should continue (dropping the failed\n   *   call) or false if the stream should quietly terminate.  If the handler\n   *   itself throws (or rethrows) an `Error`, that will be propagated.\n   *\n   * @returns A `LazyIterator` of elements passed through from upstream,\n   *   possibly filtering or terminating on upstream `next()` calls that\n   *   throw an `Error`.\n   */\n  handleErrors(handler: (error: Error) => boolean): LazyIterator<T> {\n    return new ErrorHandlingLazyIterator(this, handler);\n  }\n\n  // TODO(soergel): Implement reduce() etc.\n\n  /**\n   * Filters this stream according to `predicate`.\n   *\n   * @param predicate A function mapping a stream element to a boolean or a\n   * `Promise` for one.\n   *\n   * @returns A `LazyIterator` of elements for which the predicate was true.\n   */\n  filter(predicate: (value: T) => boolean): LazyIterator<T> {\n    return new FilterIterator(this, predicate);\n  }\n\n  /**\n   * Maps this stream through a 1-to-1 transform.\n   *\n   * @param transform A function mapping a stream element to a transformed\n   *   element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n  map<O>(transform: (value: T) => O): LazyIterator<O> {\n    return new MapIterator(this, transform);\n  }\n\n  /**\n   * Maps this stream through an async 1-to-1 transform.\n   *\n   * @param transform A function mapping a stream element to a `Promise` for a\n   *   transformed stream element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n  mapAsync<O>(transform: (value: T) => Promise<O>): LazyIterator<O> {\n    return new AsyncMapIterator(this, transform);\n  }\n\n  /**\n   * Maps this stream through a 1-to-1 transform, forcing serial execution.\n   *\n   * @param transform A function mapping a stream element to a transformed\n   *   element.\n   *\n   * @returns A `LazyIterator` of transformed elements.\n   */\n  serialMapAsync<O>(transform: (value: T) => Promise<O>): LazyIterator<O> {\n    return new AsyncMapIterator(this, transform).serial();\n  }\n\n  /**\n   * Maps this stream through a 1-to-many transform.\n   *\n   * @param transform A function mapping a stream element to an array of\n   *   transformed elements.\n   *\n   * @returns A `DataStream` of transformed elements.\n   */\n  flatmap<O>(transform: (value: T) => O[]): LazyIterator<O> {\n    return new FlatmapIterator(this, transform);\n  }\n\n  /**\n   * Apply a function to every element of the stream.\n   *\n   * @param f A function to apply to each stream element.\n   */\n  async forEachAsync(f: (value: T) => void): Promise<void> {\n    return this.map(f).resolveFully();\n  }\n\n  /**\n   * Apply a function to every element of the stream, forcing serial execution.\n   *\n   * @param f A function to apply to each stream element.  Should return 'true'\n   *   to indicate that the stream should continue, or 'false' to cause it to\n   *   terminate.\n   */\n  async serialForEach(f: (value: T) => Promise<boolean>): Promise<void> {\n    return this.serialMapAsync(f).resolveWhile(x => (x === true));\n  }\n\n  /**\n   * Groups elements into batches, represented as arrays of elements.\n   *\n   * We can think of the elements of this iterator as 'rows' (even if they are\n   * nested structures).  By the same token, consecutive values for a given\n   * key within the elements form a 'column'.  This matches the usual sense of\n   * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n   *\n   * Thus, \"Row-major\" means that the resulting batch is simply a collection of\n   * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major\n   * form, which is needed for vectorized computation.\n   *\n   * @param batchSize The number of elements desired per batch.\n   * @param smallLastBatch Whether to emit the final batch when it has fewer\n   *   than batchSize elements. Default true.\n   * @returns A `LazyIterator` of batches of elements, represented as arrays\n   *   of the original element type.\n   */\n  rowMajorBatch(batchSize: number, smallLastBatch = true): LazyIterator<T[]> {\n    return new RowMajorBatchIterator(this, batchSize, smallLastBatch);\n  }\n\n  /**\n   * Groups elements into batches, represented in column-major form.\n   *\n   * We can think of the elements of this iterator as 'rows' (even if they are\n   * nested structures).  By the same token, consecutive values for a given\n   * key within the elements form a 'column'.  This matches the usual sense of\n   * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).\n   *\n   * Thus, \"column-major\" means that the resulting batch is a (potentially\n   * nested) structure representing the columns.  Each column entry, then,\n   * contains a collection of the values found in that column for a range of\n   * input elements.  This representation allows for vectorized computation, in\n   * contrast to the row-major form.\n   *\n   * The inputs should all have the same nested structure (i.e., of arrays and\n   * dicts).  The result is a single object with the same nested structure,\n   * where the leaves are arrays collecting the values of the inputs at that\n   * location (or, optionally, the result of a custom function applied to those\n   * arrays).\n   *\n   * @param batchSize The number of elements desired per batch.\n   * @param smallLastBatch Whether to emit the final batch when it has fewer\n   *   than batchSize elements. Default true.\n   * @param zipFn: (optional) A function that expects an array of elements at a\n   *   single node of the object tree, and returns a `DeepMapResult`.  The\n   *   `DeepMapResult` either provides a result value for that node (i.e.,\n   *   representing the subtree), or indicates that the node should be processed\n   *   recursively.  The default zipFn recurses as far as possible and places\n   *   arrays at the leaves.\n   * @returns A `LazyIterator` of batches of elements, represented as an object\n   *   with collections at the leaves.\n   */\n  columnMajorBatch(\n      batchSize: number, smallLastBatch = true,\n      // tslint:disable-next-line:no-any\n      zipFn: (xs: any[]) => DeepMapResult = zipToList):\n      LazyIterator<tf.TensorContainer> {\n    // First collect the desired number of input elements as a row-major batch.\n    const rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);\n    // Now 'rotate' or 'pivot' the data, collecting all values from each column\n    // in the batch (i.e., for each key within the elements) into an array.\n    return rowBatches.map(x => deepZip(x, zipFn));\n  }\n\n  /**\n   * Concatenate this `LazyIterator` with another.\n   *\n   * @param iterator A `LazyIterator` to be concatenated onto this one.\n   * @param baseErrorHandler An optional function that can intercept `Error`s\n   *   raised during a `next()` call on the base stream.  This function can\n   *   decide whether the error should be propagated, whether the error should\n   *   be ignored, or whether the base stream should be terminated.\n   * @returns A `LazyIterator`.\n   */\n  concatenate(\n      iterator: LazyIterator<T>,\n      baseErrorHandler?: (e: Error) => boolean): LazyIterator<T> {\n    return new ChainedIterator(\n        iteratorFromItems([this, iterator]), baseErrorHandler);\n  }\n\n  /**\n   * Limits this stream to return at most `count` items.\n   *\n   * @param count The maximum number of items to provide from the stream. If\n   * a negative or undefined value is given, the entire stream is returned\n   *   unaltered.\n   */\n  take(count: number): LazyIterator<T> {\n    if (count < 0 || count == null) {\n      return this;\n    }\n    return new TakeIterator(this, count);\n  }\n\n  /**\n   * Skips the first `count` items in this stream.\n   *\n   * @param count The number of items to skip.  If a negative or undefined\n   * value is given, the entire stream is returned unaltered.\n   */\n  skip(count: number): LazyIterator<T> {\n    if (count < 0 || count == null) {\n      return this;\n    }\n    return new SkipIterator(this, count);\n  }\n\n  /**\n   * Prefetch the first `bufferSize` items in this stream.\n   *\n   * Note this prefetches Promises, but makes no guarantees about when those\n   * Promises resolve.\n   *\n   * @param bufferSize: An integer specifying the number of elements to be\n   *   prefetched.\n   */\n  prefetch(bufferSize: number): LazyIterator<T> {\n    return new PrefetchIterator(this, bufferSize);\n  }\n\n  // TODO(soergel): deep sharded shuffle, where supported\n\n  /**\n   * Randomly shuffles the elements of this stream.\n   *\n   * @param bufferSize: An integer specifying the number of elements from\n   * this stream from which the new stream will sample.\n   * @param seed: (Optional.) An integer specifying the random seed that\n   * will be used to create the distribution.\n   */\n  shuffle(windowSize: number, seed?: string): LazyIterator<T> {\n    return new ShuffleIterator(this, windowSize, seed);\n  }\n\n  /**\n   * Force an iterator to execute serially: each next() call will await the\n   * prior one, so that they cannot execute concurrently.\n   */\n  serial(): LazyIterator<T> {\n    return new SerialIterator(this);\n  }\n}\n\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on LazyIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n\n// Iterators that just extend LazyIterator directly\n// ============================================================================\n\nclass ArrayIterator<T> extends LazyIterator<T> {\n  private trav = 0;\n  constructor(protected items: T[]) {\n    super();\n  }\n\n  summary() {\n    return `Array of ${this.items.length} items`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    if (this.trav >= this.items.length) {\n      return {value: null, done: true};\n    }\n    const item = this.items[this.trav];\n    this.trav++;\n    return {value: deepClone(item), done: false};\n  }\n}\n\nclass FunctionCallIterator<T> extends LazyIterator<T> {\n  constructor(\n      protected nextFn: () => IteratorResult<T>| Promise<IteratorResult<T>>) {\n    super();\n  }\n\n  summary() {\n    return `Function call`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    try {\n      return this.nextFn();\n    } catch (e) {\n      // Modify the error message but leave the stack trace intact\n      e.message =\n          `Error thrown while iterating through a dataset: ${e.message}`;\n      throw e;\n    }\n  }\n}\n\nclass SerialIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  constructor(protected upstream: LazyIterator<T>) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Serial`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T>> {\n    return this.upstream.next();\n  }\n}\n\nclass SkipIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  count = 0;\n\n  constructor(protected upstream: LazyIterator<T>, protected maxCount: number) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Skip`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T>> {\n    // TODO(soergel): consider tradeoffs of reading in parallel, eg.\n    // collecting next() promises in an Array and then waiting for\n    // Promise.all() of those. Benefit: pseudo-parallel execution.  Drawback:\n    // maybe delayed GC.\n    while (this.count++ < this.maxCount) {\n      const skipped = await this.upstream.next();\n      // short-circuit if upstream is already empty\n      if (skipped.done) {\n        return skipped;\n      }\n      tf.dispose(skipped.value as {});\n    }\n    return this.upstream.next();\n  }\n}\n\nclass TakeIterator<T> extends LazyIterator<T> {\n  count = 0;\n  constructor(protected upstream: LazyIterator<T>, protected maxCount: number) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Take`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    if (this.count++ >= this.maxCount) {\n      return {value: null, done: true};\n    }\n    return this.upstream.next();\n  }\n}\n\n// Note this batch just groups items into row-wise element arrays.\n// Rotating these to a column-wise representation happens only at the dataset\n// level.\nclass RowMajorBatchIterator<T> extends LazyIterator<T[]> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T[]>>;\n\n  constructor(\n      protected upstream: LazyIterator<T>, protected batchSize: number,\n      protected enableSmallLastBatch = true) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> RowMajorBatch`;\n  }\n\n  async next(): Promise<IteratorResult<T[]>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T[]>> {\n    const batch: T[] = [];\n    while (batch.length < this.batchSize) {\n      const item = await this.upstream.next();\n      if (item.done) {\n        if (this.enableSmallLastBatch && batch.length > 0) {\n          return {value: batch, done: false};\n        }\n        return {value: null, done: true};\n      }\n      batch.push(item.value);\n    }\n    return {value: batch, done: false};\n  }\n}\n\nclass FilterIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  constructor(\n      protected upstream: LazyIterator<T>,\n      protected predicate: (value: T) => boolean) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Filter`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private async serialNext(): Promise<IteratorResult<T>> {\n    while (true) {\n      const item = await this.upstream.next();\n      if (item.done || this.predicate(item.value)) {\n        return item;\n      }\n      tf.dispose(item.value as {});\n    }\n  }\n}\n\nclass MapIterator<I, O> extends LazyIterator<O> {\n  constructor(\n      protected upstream: LazyIterator<I>,\n      protected transform: (value: I) => O) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Map`;\n  }\n\n  async next(): Promise<IteratorResult<O>> {\n    const item = await this.upstream.next();\n    if (item.done) {\n      return {value: null, done: true};\n    }\n    const inputTensors = tf.tensor_util.getTensorsInContainer(item.value as {});\n    // Careful: the transform may mutate the item in place.\n    // That's why we have to remember the input Tensors above, and then\n    // below dispose only those that were not passed through to the output.\n    // Note too that the transform function is responsible for tidying\n    // any intermediate Tensors.  Here we are concerned only about the\n    // inputs.\n    const mapped = this.transform(item.value);\n    const outputTensors = tf.tensor_util.getTensorsInContainer(mapped as {});\n\n    // TODO(soergel) faster intersection\n    // TODO(soergel) move to tf.disposeExcept(in, out)?\n    for (const t of inputTensors) {\n      if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n        t.dispose();\n      }\n    }\n    return {value: mapped, done: false};\n  }\n}\n\nclass ErrorHandlingLazyIterator<T> extends LazyIterator<T> {\n  count = 0;\n  constructor(\n      protected upstream: LazyIterator<T>,\n      protected handler: (error: Error) => boolean) {\n    super();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> handleErrors`;\n  }\n\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  async serialNext(): Promise<IteratorResult<T>> {\n    while (true) {\n      try {\n        return await this.upstream.next();\n      } catch (e) {\n        if (!this.handler(e)) {\n          return {value: null, done: true};\n        }\n        // If the handler returns true, loop and fetch the next upstream item.\n\n        // If the upstream iterator throws an endless stream of errors, and if\n        // the handler says to ignore them, then we loop forever here.  That is\n        // the correct behavior-- it's up to the handler to decide when to stop.\n      }\n    }\n  }\n}\n\nclass AsyncMapIterator<I, O> extends LazyIterator<O> {\n  constructor(\n      protected upstream: LazyIterator<I>,\n      protected transform: (value: I) => Promise<O>) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> AsyncMap`;\n  }\n\n  async next(): Promise<IteratorResult<O>> {\n    const item = await this.upstream.next();\n    if (item.done) {\n      return {value: null, done: true};\n    }\n    const inputTensors = tf.tensor_util.getTensorsInContainer(item.value as {});\n    // Careful: the transform may mutate the item in place.\n    // That's why we have to remember the input Tensors above, and then\n    // below dispose only those that were not passed through to the output.\n    // Note too that the transform function is responsible for tidying\n    // any intermediate Tensors.  Here we are concerned only about the\n    // inputs.\n    const mapped = await this.transform(item.value);\n    const outputTensors = tf.tensor_util.getTensorsInContainer(mapped as {});\n\n    // TODO(soergel) faster intersection\n    // TODO(soergel) move to tf.disposeExcept(in, out)?\n    for (const t of inputTensors) {\n      if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n        t.dispose();\n      }\n    }\n    return {value: mapped, done: false};\n  }\n}\n\n// Iterators that maintain a queue of pending items\n// ============================================================================\n\n/**\n * A base class for transforming streams that operate by maintaining an\n * output queue of elements that are ready to return via next().  This is\n * commonly required when the transformation is 1-to-many:  A call to next()\n * may trigger a call to the underlying stream, which will produce many\n * mapped elements of this stream-- of which we need to return only one, so\n * we have to queue the rest.\n */\nexport abstract class OneToManyIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  protected outputQueue: RingBuffer<T>;\n\n  constructor() {\n    super();\n    this.outputQueue = new GrowingRingBuffer<T>();\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  /**\n   * Read one or more chunks from upstream and process them, possibly\n   * reading or writing a carryover, and adding processed items to the\n   * output queue.  Note it's possible that no items are added to the queue\n   * on a given pump() call, even if the upstream stream is not closed\n   * (e.g., because items are filtered).\n   *\n   * @return `true` if any action was taken, i.e. fetching items from the\n   *   upstream source OR adding items to the output queue.  `false` if the\n   *   upstream source is exhausted AND nothing was added to the queue\n   * (i.e., any remaining carryover).\n   */\n  protected abstract async pump(): Promise<boolean>;\n\n  async serialNext(): Promise<IteratorResult<T>> {\n    // Fetch so that the queue contains at least one item if possible.\n    // If the upstream source is exhausted, AND there are no items left in\n    // the output queue, then this stream is also exhausted.\n    while (this.outputQueue.length() === 0) {\n      // TODO(soergel): consider parallel reads.\n      if (!await this.pump()) {\n        return {value: null, done: true};\n      }\n    }\n    return {value: this.outputQueue.shift(), done: false};\n  }\n}\nclass FlatmapIterator<I, O> extends OneToManyIterator<O> {\n  constructor(\n      protected upstream: LazyIterator<I>,\n      protected transform: (value: I) => O[]) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Flatmap`;\n  }\n\n  async pump(): Promise<boolean> {\n    const item = await this.upstream.next();\n    if (item.done) {\n      return false;\n    }\n    const inputTensors = tf.tensor_util.getTensorsInContainer(item.value as {});\n    // Careful: the transform may mutate the item in place.\n    // that's why we have to remember the input Tensors above, and then\n    // below dispose only those that were not passed through to the output.\n    // Note too that the transform function is responsible for tidying any\n    // intermediate Tensors.  Here we are concerned only about the inputs.\n    const mappedArray = this.transform(item.value);\n    const outputTensors =\n        tf.tensor_util.getTensorsInContainer(mappedArray as {});\n    this.outputQueue.pushAll(mappedArray);\n\n    // TODO(soergel) faster intersection, and deduplicate outputTensors\n    // TODO(soergel) move to tf.disposeExcept(in, out)?\n    for (const t of inputTensors) {\n      if (!tf.tensor_util.isTensorInList(t, outputTensors)) {\n        t.dispose();\n      }\n    }\n\n    return true;\n  }\n}\n\n/**\n * Provides a `LazyIterator` that concatenates a stream of underlying\n * streams.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n */\nexport class ChainedIterator<T> extends LazyIterator<T> {\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>> = null;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  private iterator: LazyIterator<T> = null;\n  private moreIterators: LazyIterator<LazyIterator<T>>;\n\n  constructor(\n      iterators: LazyIterator<LazyIterator<T>>,\n      private readonly baseErrorHandler?: (e: Error) => boolean) {\n    super();\n    this.moreIterators = iterators;\n  }\n\n  summary() {\n    const upstreamSummaries = 'TODO: fill in upstream of chained summaries';\n    return `${upstreamSummaries} -> Chained`;\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    this.lastRead = this.readFromChain(this.lastRead);\n    return this.lastRead;\n  }\n\n  private async readFromChain(lastRead: Promise<IteratorResult<T>>):\n      Promise<IteratorResult<T>> {\n    // Must await on the previous read since the previous read may have advanced\n    // the stream of streams, from which we need to read.\n    // This is unfortunate since we can't parallelize reads. Which means\n    // prefetching of chained streams is a no-op.\n    // One solution is to prefetch immediately upstream of this.\n    await lastRead;\n    if (this.iterator == null) {\n      const iteratorResult = await this.moreIterators.next();\n      if (iteratorResult.done) {\n        // No more streams to stream from.\n        return {value: null, done: true};\n      }\n      this.iterator = iteratorResult.value;\n      if (this.baseErrorHandler != null) {\n        this.iterator = this.iterator.handleErrors(this.baseErrorHandler);\n      }\n    }\n    const itemResult = await this.iterator.next();\n    if (itemResult.done) {\n      this.iterator = null;\n      return this.readFromChain(lastRead);\n    }\n    return itemResult;\n  }\n}\n\nexport enum ZipMismatchMode {\n  FAIL,      // require zipped streams to have the same length\n  SHORTEST,  // terminate zip when the first stream is exhausted\n  LONGEST    // use nulls for exhausted streams; use up the longest stream.\n}\n\n/**\n * Provides a `LazyIterator` that zips together an array, dict, or nested\n * structure of `LazyIterator`s (and perhaps additional constants).\n *\n * The underlying streams must provide elements in a consistent order such\n * that they correspond.\n *\n * Typically, the underlying streams should have the same number of\n * elements. If they do not, the behavior is determined by the\n * `mismatchMode` argument.\n *\n * The nested structure of the `iterators` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Doing this in a concurrency-safe way requires some trickery.  In\n * particular, we want this stream to return the elements from the\n * underlying streams in the correct order according to when next() was\n * called, even if the resulting Promises resolve in a different order.\n *\n * @param iterators: An array or object containing LazyIterators at the\n * leaves.\n * @param mismatchMode: Determines what to do when one underlying iterator\n * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)\n * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`\n * causes the zipped iterator to terminate with the furst underlying\n * streams, so elements remaining on the longer streams are ignored.\n * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling\n * in nulls for the exhausted streams, until all streams are exhausted.\n */\nclass ZipIterator<O extends tf.TensorContainer> extends LazyIterator<O> {\n  private count = 0;\n  private currentPromise: Promise<IteratorResult<O>> = null;\n\n  constructor(\n      protected readonly iterators: IteratorContainer,\n      protected readonly mismatchMode: ZipMismatchMode = ZipMismatchMode.FAIL) {\n    super();\n  }\n\n  summary() {\n    const upstreamSummaries = 'TODO: fill in upstream of zip summaries';\n    return `{${upstreamSummaries}} -> Zip`;\n  }\n\n  private async nextState(afterState: Promise<IteratorResult<O>>):\n      Promise<IteratorResult<O>> {\n    // This chaining ensures that the underlying next() are not even called\n    // before the previous ones have resolved.\n    await afterState;\n\n    // Collect underlying iterator \"done\" signals as a side effect in\n    // getNext()\n    let numIterators = 0;\n    let iteratorsDone = 0;\n\n    function getNext(container: IteratorContainer): DeepMapAsyncResult {\n      if (container instanceof LazyIterator) {\n        const result = container.next();\n        return {\n          value: result.then(x => {\n            numIterators++;\n            if (x.done) {\n              iteratorsDone++;\n            }\n            return x.value;\n          }),\n          recurse: false\n        };\n      } else {\n        return {value: null, recurse: true};\n      }\n    }\n\n    const mapped: O = await deepMapAndAwaitAll(this.iterators, getNext);\n\n    if (numIterators === iteratorsDone) {\n      // The streams have all ended.\n      return {value: null, done: true};\n    }\n    if (iteratorsDone > 0) {\n      switch (this.mismatchMode) {\n        case ZipMismatchMode.FAIL:\n          throw new Error(\n              'Zipped streams should have the same length. ' +\n              `Mismatched at element ${this.count}.`);\n        case ZipMismatchMode.SHORTEST:\n          return {value: null, done: true};\n        case ZipMismatchMode.LONGEST:\n        default:\n          // Continue.  The exhausted streams already produced value: null.\n      }\n    }\n\n    this.count++;\n    return {value: mapped, done: false};\n  }\n\n  async next(): Promise<IteratorResult<O>> {\n    this.currentPromise = this.nextState(this.currentPromise);\n    return this.currentPromise;\n  }\n}\n\n// Iterators that maintain a ring buffer of pending promises\n// ============================================================================\n\n/**\n * A stream that prefetches a given number of items from an upstream source,\n * returning them in FIFO order.\n *\n * Note this prefetches Promises, but makes no guarantees about when those\n * Promises resolve.\n */\nexport class PrefetchIterator<T> extends LazyIterator<T> {\n  protected buffer: RingBuffer<Promise<IteratorResult<T>>>;\n\n  constructor(\n      protected upstream: LazyIterator<T>, protected bufferSize: number) {\n    super();\n    this.buffer = new RingBuffer<Promise<IteratorResult<T>>>(bufferSize);\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Prefetch`;\n  }\n\n  /**\n   * Refill the prefetch buffer.  Returns only after the buffer is full, or\n   * the upstream source is exhausted.\n   */\n  protected refill() {\n    while (!this.buffer.isFull()) {\n      const v = this.upstream.next();\n      this.buffer.push(v);\n    }\n  }\n\n  next(): Promise<IteratorResult<T>> {\n    this.refill();\n    // This shift will never throw an error because the buffer is always\n    // full after a refill. If the stream is exhausted, the buffer will be\n    // full of Promises that will resolve to the end-of-stream signal.\n    return this.buffer.shift();\n  }\n}\n\n/**\n * A stream that performs a sliding-window random shuffle on an upstream\n * source. This is like a `PrefetchIterator` except that the items are\n * returned in randomized order.  Mixing naturally improves as the buffer\n * size increases.\n */\nexport class ShuffleIterator<T> extends PrefetchIterator<T> {\n  private readonly random: seedrandom.prng;\n\n  // Strict Promise execution order:\n  // a next() call may not even begin until the previous one completes.\n  private lastRead: Promise<IteratorResult<T>>;\n\n  // Local state that should not be clobbered by out-of-order execution.\n  private upstreamExhausted = false;\n\n  constructor(\n      protected upstream: LazyIterator<T>, protected windowSize: number,\n      seed?: string) {\n    super(upstream, windowSize);\n    this.random = seedrandom.alea(seed || tf.util.now().toString());\n    this.lastRead = Promise.resolve({value: null, done: false});\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    // This sets this.lastRead to a new Promise right away, as opposed to\n    // saying `await this.lastRead; this.lastRead = this.serialNext();` which\n    // would not work because this.nextRead would be updated only after the\n    // promise resolves.\n    this.lastRead = this.lastRead.then(() => this.serialNext());\n    return this.lastRead;\n  }\n\n  private randomInt(max: number) {\n    return Math.floor(this.random() * max);\n  }\n\n  protected chooseIndex(): number {\n    return this.randomInt(this.buffer.length());\n  }\n\n  async serialNext(): Promise<IteratorResult<T>> {\n    // TODO(soergel): consider performance\n    if (!this.upstreamExhausted) {\n      this.refill();\n    }\n    while (!this.buffer.isEmpty()) {\n      const chosenIndex = this.chooseIndex();\n      const result = await this.buffer.shuffleExcise(chosenIndex);\n      if (result.done) {\n        this.upstreamExhausted = true;\n      } else {\n        this.refill();\n        return result;\n      }\n    }\n    return {value: null, done: true};\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\n// tslint:disable:no-any\n\n/**\n * A return value for a mapping function that can be applied via deepMap.\n *\n * If recurse is true, the value should be empty, and iteration will continue\n * into the object or array.\n */\nexport type DeepMapResult = {\n  value: any,\n  recurse: boolean\n};\n\n/**\n * Apply a mapping function to a nested structure in a recursive manner.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapResult`.  The `DeepMapResult` either provides a\n *   replacement value for that node (i.e., replacing the subtree), or indicates\n *   that the node should be processed recursively.\n */\nexport function deepMap(input: any, mapFn: (x: any) => DeepMapResult): any|\n    any[] {\n  return deepMapInternal(input, mapFn);\n}\n\n/**\n * @param seen: A Map of known object mappings (i.e., memoized results of\n *   `mapFn()`)\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\nfunction deepMapInternal(\n    input: any, mapFn: (x: any) => DeepMapResult,\n    seen: Map<any, any> = new Map(), containedIn: Set<{}> = new Set()): any|\n    any[] {\n  if (input == null) {\n    return null;\n  }\n  if (typeof Blob === 'function' && input instanceof Blob) {\n    return input.slice();\n  }\n\n  if (containedIn.has(input)) {\n    throw new Error('Circular references are not supported.');\n  }\n  if (seen.has(input)) {\n    return seen.get(input);\n  }\n  const result = mapFn(input);\n\n  if (result.recurse && result.value !== null) {\n    throw new Error(\n        'A deep map function may not return both a value and recurse=true.');\n  }\n\n  if (!result.recurse) {\n    seen.set(input, result.value);\n    return result.value;\n  } else if (isIterable(input)) {\n    // tslint:disable-next-line:no-any\n    const mappedIterable: any|any[] = Array.isArray(input) ? [] : {};\n    containedIn.add(input);\n    for (const k in input) {\n      const child = input[k];\n      const childResult = deepMapInternal(child, mapFn, seen, containedIn);\n      mappedIterable[k] = childResult;\n    }\n    containedIn.delete(input);\n    if (input.__proto__) {\n      mappedIterable.__proto__ = input.__proto__;\n    }\n    return mappedIterable;\n  } else {\n    throw new Error(`Can't recurse into non-iterable type: ${input}`);\n  }\n}\n\n// TODO(soergel, kangyizhang) Reconsider naming of deepZip() to avoid confusion\n// with zip()\n\n/**\n * Zip nested structures together in a recursive manner.\n *\n * This has the effect of transposing or pivoting data, e.g. converting it from\n * a row-major representation to a column-major representation.\n *\n * For example, `deepZip([{a: 1, b: 2}, {a: 3, b: 4}])` returns\n * `{a: [1, 3], b: [2, 4]}`.\n *\n * The inputs should all have the same nested structure (i.e., of arrays and\n * dicts).  The result is a single object with the same nested structure, where\n * the leaves are arrays collecting the values of the inputs at that location\n * (or, optionally, the result of a custom function applied to those arrays).\n *\n * @param inputs: An array of the objects to zip together.\n * @param zipFn: (optional) A function that expects an array of elements at a\n *   single node of the object tree, and returns a `DeepMapResult`.  The\n *   `DeepMapResult` either provides a result value for that node (i.e.,\n *   representing the subtree), or indicates that the node should be processed\n *   recursively.  The default zipFn recurses as far as possible and places\n *   arrays at the leaves.\n */\nexport function deepZip(\n    inputs: any[], zipFn: (xs: any[]) => DeepMapResult = zipToList): any|any[] {\n  return deepZipInternal(inputs, zipFn);\n}\n\n/**\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\nfunction deepZipInternal(\n    inputs: any[], zipFn: (xs: any[]) => DeepMapResult,\n    containedIn: Set<{}> = new Set()): any|any[] {\n  // The recursion follows the structure of input 0; it's assumed that all the\n  // other inputs have the same structure.\n  const input = inputs[0];\n  if (containedIn.has(input)) {\n    throw new Error('Circular references are not supported.');\n  }\n  const result = zipFn(inputs);\n\n  if (result.recurse && result.value !== null) {\n    throw new Error(\n        'A deep zip function may not return both a value and recurse=true.');\n  }\n\n  if (!result.recurse) {\n    return result.value;\n  } else if (isIterable(input)) {\n    // tslint:disable-next-line:no-any\n    const mappedIterable: any|any[] = Array.isArray(input) ? [] : {};\n    containedIn.add(input);\n    for (const k in input) {\n      const children = inputs.map(x => x[k]);\n      const childResult = deepZipInternal(children, zipFn, containedIn);\n      mappedIterable[k] = childResult;\n    }\n    containedIn.delete(input);\n    return mappedIterable;\n  } else {\n    throw new Error(`Can't recurse into non-iterable type: ${input}`);\n  }\n}\n\n// tslint:disable-next-line:no-any\nexport function zipToList(x: any[]): DeepMapResult {\n  if (x === null) {\n    return null;\n  }\n  // TODO(soergel): validate array type?\n\n  if (isIterable(x[0])) {\n    return {value: null, recurse: true};\n  } else {\n    return {value: x, recurse: false};\n  }\n}\n\n/**\n * A return value for an async map function for use with deepMapAndAwaitAll.\n *\n * If recurse is true, the value should be empty, and iteration will continue\n * into the object or array.\n */\nexport type DeepMapAsyncResult = {\n  value: Promise<any>,\n  recurse: boolean\n};\n\n/**\n * Apply an async mapping function to a nested structure in a recursive manner.\n *\n * This first creates a nested structure of Promises, and then awaits all of\n * those, resulting in a single Promise for a resolved nested structure.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapAsyncResult`.  The `DeepMapAsyncResult` either provides\n *   a `Promise` for a replacement value for that node (i.e., replacing the\n *   subtree), or indicates that the node should be processed recursively.  Note\n *   that the decision whether or not to recurse must be made immediately; only\n *   the mapped value may be promised.\n */\nexport async function deepMapAndAwaitAll(\n    input: any, mapFn: (x: any) => DeepMapAsyncResult): Promise<any|any[]> {\n  const seen: Map<any, any> = new Map();\n\n  // First do a normal deepMap, collecting Promises in 'seen' as a side effect.\n  deepMapInternal(input, mapFn, seen);\n\n  // Replace the Promises in 'seen' in place.\n  // Note TypeScript provides no async map iteration, and regular map iteration\n  // is broken too, so sadly we have to do Array.from() to make it work.\n  // (There's no advantage to Promise.all(), and that would be tricky anyway.)\n  for (const key of Array.from(seen.keys())) {\n    const value = seen.get(key);\n    if (tf.util.isPromise(value)) {\n      const mappedValue = await value;\n      seen.set(key, mappedValue);\n    }\n  }\n\n  // Normal deepMap again, this time filling in the resolved values.\n  // It's unfortunate that we have to do two passes.\n  // TODO(soergel): test performance and think harder about a fast solution.\n  const result = deepMapInternal(input, mapFn, seen);\n  return result;\n}\n\n/**\n * Determine whether the argument is iterable.\n *\n * @returns true if the argument is an array or any non-Tensor object.\n */\n// tslint:disable-next-line:no-any\nexport function isIterable(obj: any): boolean {\n  let isTextDecoder = false;\n  if (tf.env().get('IS_BROWSER')) {\n    isTextDecoder = obj instanceof TextDecoder;\n  } else {\n    // tslint:disable-next-line:no-require-imports\n    const {StringDecoder} = require('string_decoder');\n    isTextDecoder = obj instanceof StringDecoder;\n  }\n  return obj != null && (!ArrayBuffer.isView(obj)) &&\n      (Array.isArray(obj) ||\n       (typeof obj === 'object' && !(obj instanceof tf.Tensor) &&\n        !(obj instanceof Promise) && !isTextDecoder));\n}\n\n/**\n * Determine whether the argument can be converted to Tensor.\n *\n * Tensors, primitives, arrays, and TypedArrays all qualify; anything else does\n * not.\n *\n * @returns true if the argument can be converted to Tensor.\n */\n// tslint:disable-next-line:no-any\nexport function canTensorify(obj: any): boolean {\n  return obj == null || isPrimitive(obj) || Array.isArray(obj) ||\n      (typeof obj === 'object' && (obj instanceof tf.Tensor)) ||\n      tf.util.isTypedArray(obj);\n}\n\n/**\n * Returns true if the given `value` is a primitive type. Otherwise returns\n * false. This is equivalant to node util.isPrimitive\n */\nfunction isPrimitive(value: any): boolean {\n  return (\n      value === null ||\n      (typeof value !== 'object' && typeof value !== 'function'));\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {deepMap, DeepMapResult, isIterable} from './deep_map';\n\nexport function deepClone<T>(container: T): T {\n  return deepMap(container, cloneIfTensor);\n}\n\n// tslint:disable-next-line: no-any\nfunction cloneIfTensor(item: any): DeepMapResult {\n  if (item instanceof tf.Tensor) {\n    return ({value: item.clone(), recurse: false});\n  } else if (isIterable(item)) {\n    return {value: null, recurse: true};\n  } else {\n    return {value: item, recurse: false};\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\n/**\n * A ring buffer, providing O(1) FIFO, LIFO, and related operations.\n */\nexport class RingBuffer<T> {\n  // Note we store the indices in the range 0 <= index < 2*capacity.\n  // This allows us to distinguish the full from the empty case.\n  // See https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/\n  protected begin = 0;  // inclusive\n  protected end = 0;    // exclusive\n  protected doubledCapacity: number;\n\n  protected data: T[];\n\n  /**\n   * Constructs a `RingBuffer`.\n   * @param capacity The number of items that the buffer can accomodate.\n   */\n  constructor(public capacity: number) {\n    if (capacity == null) {\n      throw new RangeError('Can\\'t create a ring buffer of unknown capacity.');\n    }\n    if (capacity < 1) {\n      throw new RangeError('Can\\'t create ring buffer of capacity < 1.');\n    }\n    this.data = new Array<T>(capacity);\n    this.doubledCapacity = 2 * capacity;\n  }\n\n  /**\n   * Map any index into the range 0 <= index < 2*capacity.\n   */\n  protected wrap(index: number) {\n    // don't trust % on negative numbers\n    while (index < 0) {\n      index += this.doubledCapacity;\n    }\n    return index % this.doubledCapacity;\n  }\n\n  protected get(index: number) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t get item at a negative index.');\n    }\n    return this.data[index % this.capacity];\n  }\n\n  protected set(index: number, value: T) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t set item at a negative index.');\n    }\n    this.data[index % this.capacity] = value;\n  }\n\n  /**\n   * Returns the current number of items in the buffer.\n   */\n  length(): number {\n    let length = this.end - this.begin;\n    if (length < 0) {\n      length = this.doubledCapacity + length;\n    }\n    return length;\n  }\n\n  /**\n   * Reports whether the buffer is full.\n   * @returns true if the number of items in the buffer equals its capacity, and\n   *   false otherwise.\n   */\n  isFull() {\n    return this.length() === this.capacity;\n  }\n\n  /**\n   * Reports whether the buffer is empty.\n   * @returns true if the number of items in the buffer equals zero, and\n   *   false otherwise.\n   */\n  isEmpty() {\n    return this.length() === 0;\n  }\n\n  /**\n   * Adds an item to the end of the buffer.\n   */\n  push(value: T) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n    this.set(this.end, value);\n    this.end = this.wrap(this.end + 1);\n  }\n\n  /**\n   * Adds many items to the end of the buffer, in order.\n   */\n  pushAll(values: T[]) {\n    for (const value of values) {\n      this.push(value);\n    }\n  }\n\n  /**\n   * Removes and returns the last item in the buffer.\n   */\n  pop(): T {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    this.end = this.wrap(this.end - 1);\n    const result = this.get(this.end);\n    this.set(this.end, undefined);\n    return result;\n  }\n\n  /**\n   * Adds an item to the beginning of the buffer.\n   */\n  unshift(value: T) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n    this.begin = this.wrap(this.begin - 1);\n    this.set(this.begin, value);\n  }\n\n  /**\n   * Removes and returns the first item in the buffer.\n   */\n  shift(): T {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    const result = this.get(this.begin);\n    this.set(this.begin, undefined);\n    this.begin = this.wrap(this.begin + 1);\n    return result;\n  }\n\n  /**\n   * Removes and returns a specific item in the buffer, and moves the last item\n   * to the vacated slot.  This is useful for implementing a shuffling stream.\n   * Note that this operation necessarily scrambles the original order.\n   *\n   * @param relativeIndex: the index of the item to remove, relative to the\n   *   first item in the buffer (e.g., hiding the ring nature of the underlying\n   *   storage).\n   */\n  shuffleExcise(relativeIndex: number): T {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    const index = this.wrap(this.begin + relativeIndex);\n    const result = this.get(index);\n    this.set(index, this.pop());\n    return result;\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {RingBuffer} from './ring_buffer';\n\nexport class GrowingRingBuffer<T> extends RingBuffer<T> {\n  private static INITIAL_CAPACITY = 32;\n\n  /**\n   * Constructs a `GrowingRingBuffer`.\n   */\n  constructor() {\n    super(GrowingRingBuffer.INITIAL_CAPACITY);\n  }\n\n  isFull() {\n    return false;\n  }\n\n  push(value: T) {\n    if (super.isFull()) {\n      this.expand();\n    }\n    super.push(value);\n  }\n\n  unshift(value: T) {\n    if (super.isFull()) {\n      this.expand();\n    }\n    super.unshift(value);\n  }\n\n  /**\n   * Doubles the capacity of the buffer.\n   */\n  private expand() {\n    const newCapacity = this.capacity * 2;\n    const newData = new Array<T>(newCapacity);\n    const len = this.length();\n\n    // Rotate the buffer to start at index 0 again, since we can't just\n    // allocate more space at the end.\n    for (let i = 0; i < len; i++) {\n      newData[i] = this.get(this.wrap(this.begin + i));\n    }\n\n    this.data = newData;\n    this.capacity = newCapacity;\n    this.doubledCapacity = 2 * this.capacity;\n    this.begin = 0;\n    this.end = len;\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {Dataset} from '../dataset';\nimport {DataSource} from '../datasource';\nimport {LazyIterator} from '../iterators/lazy_iterator';\n\n/**\n * Represents a potentially large collection of text lines.\n *\n * The results are not batched.\n */\nexport class TextLineDataset extends Dataset<string> {\n  /**\n   * Create a `TextLineDataset`.\n   *\n   * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\n   */\n  constructor(protected readonly input: DataSource) {\n    super();\n  }\n\n  async iterator(): Promise<LazyIterator<string>> {\n    const inputIterator = await this.input.iterator();\n    const utf8Iterator = inputIterator.decodeUTF8();\n    const lineIterator = utf8Iterator.split('\\n').map(line => {\n      // Windows/DOS format text file has extra line breaker at the end of line.\n      if (line.endsWith('\\r')) {\n        line = line.slice(0, -1);\n      }\n      return line;\n    });\n    return lineIterator;\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {TensorContainer, util} from '@tensorflow/tfjs-core';\nimport {Dataset} from '../dataset';\nimport {DataSource} from '../datasource';\nimport {LazyIterator} from '../iterators/lazy_iterator';\nimport {ColumnConfig, CSVConfig} from '../types';\nimport {TextLineDataset} from './text_line_dataset';\n\nconst CODE_QUOTE = '\"';\nconst STATE_OUT = Symbol('out');\nconst STATE_FIELD = Symbol('field');\nconst STATE_QUOTE = Symbol('quote');\nconst STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');\nconst STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');\n\n/**\n * Represents a potentially large collection of delimited text records.\n *\n * The produced `TensorContainer`s each contain one key-value pair for\n * every column of the table.  When a field is empty in the incoming data, the\n * resulting value is `undefined`, or throw error if it is required.  Values\n * that can be parsed as numbers are emitted as type `number`, other values\n * are parsed as `string`.\n *\n * The results are not batched.\n *\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\n */\nexport class CSVDataset extends Dataset<TensorContainer> {\n  base: TextLineDataset;\n  private hasHeader = true;\n  private fullColumnNames: string[] = null;\n  private columnNamesValidated = false;\n  private columnConfigs: {[key: string]: ColumnConfig} = null;\n  private configuredColumnsOnly = false;\n  private delimiter = ',';\n  private delimWhitespace = false;\n\n  /**\n   * Returns column names of the csv dataset. If `configuredColumnsOnly` is\n   * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is\n   * false and `columnNames` is provided, `columnNames`. If\n   * `configuredColumnsOnly` is false and `columnNames` is not provided, return\n   * all column names parsed from the csv file. For example usage please go to\n   * `tf.data.csv`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  async columnNames() {\n    if (!this.columnNamesValidated) {\n      await this.setColumnNames();\n    }\n    return this.configuredColumnsOnly ? Object.keys(this.columnConfigs) :\n                                        this.fullColumnNames;\n  }\n\n  /* 1) If `columnNames` is provided as string[], use this string[] as output\n   * keys in corresponding order. The length must match the number of inferred\n   * columns if `hasHeader` is true .\n   * 2) If `columnNames` is not provided, parse header line as `columnNames` if\n   * hasHeader is true. If `hasHeader` is false, throw an error.\n   * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must\n   * exist in parsed `columnNames`.\n   */\n  private async setColumnNames() {\n    const columnNamesFromFile = await this.maybeReadHeaderLine();\n    if (!this.fullColumnNames && !columnNamesFromFile) {\n      // Throw an error if columnNames is not provided and no header line.\n      throw new Error(\n          'Column names must be provided if there is no header line.');\n    } else if (this.fullColumnNames && columnNamesFromFile) {\n      // Check provided columnNames match header line.\n      util.assert(\n          columnNamesFromFile.length === this.fullColumnNames.length,\n          () => 'The length of provided columnNames (' +\n              this.fullColumnNames.length.toString() +\n              ') does not match the length of the header line read from ' +\n              'file (' + columnNamesFromFile.length.toString() + ').');\n    }\n    if (!this.fullColumnNames) {\n      this.fullColumnNames = columnNamesFromFile;\n    }\n    // Check if there are duplicate column names.\n    const counts: {[key: string]: number} = this.fullColumnNames.reduce(\n        (countAcc: {[key: string]: number}, name) => {\n          countAcc[name] = (countAcc[name] + 1) || 1;\n          return countAcc;\n        },\n        {});\n    const duplicateNames =\n        Object.keys(counts).filter((name) => (counts[name] > 1));\n    util.assert(\n        duplicateNames.length === 0,\n        () => 'Duplicate column names found: ' + duplicateNames.toString());\n    // Check if keys in columnConfigs match columnNames.\n    if (this.columnConfigs) {\n      for (const key of Object.keys(this.columnConfigs)) {\n        const index = this.fullColumnNames.indexOf(key);\n        if (index === -1) {\n          throw new Error(\n              'The key \"' + key +\n              '\" provided in columnConfigs does not match any of the column ' +\n              'names (' + this.fullColumnNames.toString() + ').');\n        }\n      }\n    }\n    this.columnNamesValidated = true;\n  }\n\n  private async maybeReadHeaderLine() {\n    if (this.hasHeader) {\n      const iter = await this.base.iterator();\n      const firstElement = await iter.next();\n      if (firstElement.done) {\n        throw new Error('No data was found for CSV parsing.');\n      }\n      const firstLine: string = firstElement.value;\n      const headers = this.parseRow(firstLine, false);\n      return headers;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Create a `CSVDataset`.\n   *\n   * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\n   * @param csvConfig (Optional) A CSVConfig object that contains configurations\n   *     of reading and decoding from CSV file(s).\n   *\n   *     hasHeader: (Optional) A boolean value that indicates whether the first\n   *     row of provided CSV file is a header line with column names, and should\n   *     not be included in the data. Defaults to `true`.\n   *\n   *     columnNames: (Optional) A list of strings that corresponds to\n   *     the CSV column names, in order. If provided, it ignores the column\n   *     names inferred from the header row. If not provided, infers the column\n   *     names from the first row of the records. If hasHeader is false and\n   *     columnNames is not provided, this method throws an error.\n   *\n   *     columnConfigs: (Optional) A dictionary whose key is column names, value\n   *     is an object stating if this column is required, column's data type,\n   *     default value, and if this column is label. If provided, keys must\n   *     correspond to names provided in columnNames or inferred from the file\n   *     header lines. If isLabel is true any column, returns an array of two\n   *     items: the first item is a dict of features key/value pairs, the second\n   *     item is a dict of labels key/value pairs. If no feature is marked as\n   *     label, returns a dict of features only.\n   *\n   *     configuredColumnsOnly (Optional) If true, only columns provided in\n   *     columnConfigs will be parsed and provided during iteration.\n   *\n   *     delimiter (Optional) The string used to parse each line of the input\n   *     file. Defaults to `,`.\n   */\n  constructor(protected readonly input: DataSource, csvConfig?: CSVConfig) {\n    super();\n    this.base = new TextLineDataset(input);\n    if (!csvConfig) {\n      csvConfig = {};\n    }\n    this.hasHeader = csvConfig.hasHeader === false ? false : true;\n    this.fullColumnNames = csvConfig.columnNames;\n    this.columnConfigs = csvConfig.columnConfigs;\n    this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;\n    if (csvConfig.delimWhitespace) {\n      util.assert(\n          csvConfig.delimiter == null,\n          () =>\n              'Delimiter should not be provided when delimWhitespace is true.');\n      this.delimWhitespace = true;\n      this.delimiter = ' ';\n    } else {\n      this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';\n    }\n  }\n\n  async iterator(): Promise<LazyIterator<TensorContainer>> {\n    if (!this.columnNamesValidated) {\n      await this.setColumnNames();\n    }\n    let lines = await this.base.iterator();\n    if (this.hasHeader) {\n      // We previously read the first line to get the columnNames.\n      // Now that we're providing data, skip it.\n      lines = lines.skip(1);\n    }\n    return lines.map(x => this.makeDataElement(x));\n  }\n\n  makeDataElement(line: string): TensorContainer {\n    const values = this.parseRow(line);\n    const features: {[key: string]: TensorContainer} = {};\n    const labels: {[key: string]: TensorContainer} = {};\n\n    for (let i = 0; i < this.fullColumnNames.length; i++) {\n      const key = this.fullColumnNames[i];\n      const config = this.columnConfigs ? this.columnConfigs[key] : null;\n      if (this.configuredColumnsOnly && !config) {\n        // This column is not selected.\n        continue;\n      } else {\n        const value = values[i];\n        let parsedValue = null;\n        if (value === '') {\n          // If default value is provided, use it. If default value is not\n          // provided, set as undefined.\n          if (config && config.default !== undefined) {\n            parsedValue = config.default;\n          } else if (config && (config.required || config.isLabel)) {\n            throw new Error(\n                `Required column ${key} is empty in this line: ${line}`);\n          } else {\n            parsedValue = undefined;\n          }\n        } else {\n          // A value is present, so parse it based on type\n          const valueAsNum = Number(value);\n          if (isNaN(valueAsNum)) {\n            // The value is a string and this column is declared as boolean\n            // in config, parse it as boolean.\n            if (config && config.dtype === 'bool') {\n              parsedValue = this.getBoolean(value);\n            } else {\n              // Set value as string\n              parsedValue = value;\n            }\n          } else if (!config || !config.dtype) {\n            // If this value is a number and no type config is provided, return\n            // it as number.\n            parsedValue = valueAsNum;\n          } else {\n            // If this value is a number and data type is provided, parse it\n            // according to provided data type.\n            switch (config.dtype) {\n              case 'float32':\n                parsedValue = valueAsNum;\n                break;\n              case 'int32':\n                parsedValue = Math.floor(valueAsNum);\n                break;\n              case 'bool':\n                parsedValue = this.getBoolean(value);\n                break;\n              default:\n                parsedValue = valueAsNum;\n            }\n          }\n        }\n        // Check if this column is label.\n        (config && config.isLabel) ? labels[key] = parsedValue :\n                                     features[key] = parsedValue;\n      }\n    }\n    // If label exists, return an object of features and labels as {xs:features,\n    // ys:labels}, otherwise return features only.\n    if (Object.keys(labels).length === 0) {\n      return features;\n\n    } else {\n      return {xs: features, ys: labels};\n    }\n  }\n\n  private getBoolean(value: string): number {\n    if (value === '1' || value.toLowerCase() === 'true') {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  // adapted from https://beta.observablehq.com/@mbostock/streaming-csv\n  private parseRow(line: string, validateElementCount = true): string[] {\n    const result: string[] = [];\n    let readOffset = 0;\n    const readLength = line.length;\n    let currentState = STATE_OUT;\n    // Goes through the line to parse quote.\n    for (let i = 0; i < readLength; i++) {\n      switch (currentState) {\n        // Before enter a new field\n        case STATE_OUT:\n          switch (line.charAt(i)) {\n            // Enter a quoted field\n            case CODE_QUOTE:\n              readOffset = i + 1;\n              currentState = STATE_QUOTE;\n              break;\n            // Read an empty field\n            case this.delimiter:\n              readOffset = i + 1;\n              // If delimiter is white space and configured to collapse\n              // multiple white spaces, ignore this white space.\n              if (this.delimiter === ' ' && this.delimWhitespace) {\n                break;\n              }\n              result.push('');\n              currentState = STATE_OUT;\n              break;\n            // Enter an unquoted field\n            default:\n              currentState = STATE_FIELD;\n              readOffset = i;\n              break;\n          }\n          break;\n        // In an unquoted field\n        case STATE_FIELD:\n          switch (line.charAt(i)) {\n            // Exit an unquoted field, add it to result\n            case this.delimiter:\n              result.push(line.substring(readOffset, i));\n              currentState = STATE_OUT;\n              readOffset = i + 1;\n              break;\n            default:\n          }\n          break;\n        // In a quoted field\n        case STATE_QUOTE:\n          switch (line.charAt(i)) {\n            // Read a quote after a quote\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE_AFTER_QUOTE;\n              break;\n            default:\n          }\n          break;\n        // This state means it's right after a second quote in a field\n        case STATE_QUOTE_AFTER_QUOTE:\n          switch (line.charAt(i)) {\n            // Finished a quoted field\n            case this.delimiter:\n              result.push(line.substring(readOffset, i - 1));\n              currentState = STATE_OUT;\n              readOffset = i + 1;\n              break;\n            // Finished a quoted part in a quoted field\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE;\n              break;\n            // In a quoted part in a quoted field\n            default:\n              currentState = STATE_WITHIN_QUOTE_IN_QUOTE;\n              break;\n          }\n          break;\n        case STATE_WITHIN_QUOTE_IN_QUOTE:\n          switch (line.charAt(i)) {\n            // Exit a quoted part in a quoted field\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE;\n              break;\n            default:\n          }\n          break;\n        default:\n      }\n    }\n    // Adds last item based on if it is quoted.\n    if (currentState === STATE_QUOTE_AFTER_QUOTE) {\n      result.push(line.substring(readOffset, readLength - 1));\n    } else {\n      result.push(line.substring(readOffset));\n    }\n    // Check if each row has the same number of elements as column names.\n    if (validateElementCount && result.length !== this.fullColumnNames.length) {\n      throw new Error(`Invalid row in csv file. Should have ${\n          this.fullColumnNames.length} elements in a row, but got ${result}`);\n    }\n    return result;\n  }\n}\n\n// TODO(soergel): add more basic datasets for parity with tf.data\n// tf.data.FixedLengthRecordDataset()\n// tf.data.TFRecordDataset()\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {env, Tensor, tensor, Tensor2D, Tensor3D, TensorContainer, util} from '@tensorflow/tfjs-core';\nimport {MicrophoneConfig} from '../types';\nimport {LazyIterator} from './lazy_iterator';\n\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\nexport class MicrophoneIterator extends LazyIterator<TensorContainer> {\n  private isClosed = false;\n  private stream: MediaStream;\n  private readonly fftSize: number;\n  private readonly columnTruncateLength: number;\n  private freqData: Float32Array;\n  private timeData: Float32Array;\n  private readonly numFrames: number;\n  private analyser: AnalyserNode;\n  private audioContext: AudioContext;\n  private sampleRateHz: number;\n  private readonly audioTrackConstraints: MediaTrackConstraints;\n  private readonly smoothingTimeConstant: number;\n  private readonly includeSpectrogram: boolean;\n  private readonly includeWaveform: boolean;\n\n  private constructor(protected readonly microphoneConfig: MicrophoneConfig) {\n    super();\n    this.fftSize = microphoneConfig.fftSize || 1024;\n    const fftSizeLog2 = Math.log2(this.fftSize);\n    if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 ||\n        !Number.isInteger(fftSizeLog2)) {\n      throw new Error(\n          `Invalid fftSize: it must be a power of 2 between ` +\n          `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n    }\n\n    this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n    this.sampleRateHz = microphoneConfig.sampleRateHz;\n    this.columnTruncateLength =\n        microphoneConfig.columnTruncateLength || this.fftSize;\n    this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n    this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n\n    this.includeSpectrogram =\n        microphoneConfig.includeSpectrogram === false ? false : true;\n    this.includeWaveform =\n        microphoneConfig.includeWaveform === true ? true : false;\n    if (!this.includeSpectrogram && !this.includeWaveform) {\n      throw new Error(\n          'Both includeSpectrogram and includeWaveform are false. ' +\n          'At least one type of data should be returned.');\n    }\n  }\n\n  summary() {\n    return `microphone`;\n  }\n\n  // Construct a MicrophoneIterator and start the audio stream.\n  static async create(microphoneConfig: MicrophoneConfig = {}) {\n    if (!env().get('IS_BROWSER')) {\n      throw new Error(\n          'microphone API is only supported in browser environment.');\n    }\n\n    const microphoneIterator = new MicrophoneIterator(microphoneConfig);\n\n    // Call async function start() to initialize the audio stream.\n    await microphoneIterator.start();\n\n    return microphoneIterator;\n  }\n\n  // Start the audio stream and FFT.\n  async start(): Promise<void> {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioTrackConstraints == null ? true :\n                                                    this.audioTrackConstraints,\n        video: false\n      });\n    } catch (e) {\n      throw new Error(\n          `Error thrown while initializing video stream: ${e.message}`);\n    }\n\n    if (!this.stream) {\n      throw new Error('Could not obtain audio from microphone.');\n    }\n\n    const ctxConstructor =\n        // tslint:disable-next-line:no-any\n        (window as any).AudioContext || (window as any).webkitAudioContext;\n    this.audioContext = new ctxConstructor();\n\n    if (!this.sampleRateHz) {\n      // If sample rate is not provided, use the available sample rate on\n      // device.\n      this.sampleRateHz = this.audioContext.sampleRate;\n    } else if (this.audioContext.sampleRate !== this.sampleRateHz) {\n      throw new Error(\n          `Mismatch in sampling rate: ` +\n          `Expected: ${this.sampleRateHz}; ` +\n          `Actual: ${this.audioContext.sampleRate}`);\n    }\n\n    const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = this.fftSize * 2;\n    this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n    streamSource.connect(this.analyser);\n    this.freqData = new Float32Array(this.fftSize);\n    this.timeData = new Float32Array(this.fftSize);\n    return;\n  }\n\n  async next(): Promise<IteratorResult<TensorContainer>> {\n    if (this.isClosed) {\n      return {value: null, done: true};\n    }\n\n    let spectrogramTensor: Tensor;\n    let waveformTensor: Tensor;\n\n    const audioDataQueue = await this.getAudioData();\n    if (this.includeSpectrogram) {\n      const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n      spectrogramTensor = this.getTensorFromAudioDataArray(\n          freqData, [this.numFrames, this.columnTruncateLength, 1]);\n    }\n    if (this.includeWaveform) {\n      const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n      waveformTensor = this.getTensorFromAudioDataArray(\n          timeData, [this.numFrames * this.fftSize, 1]);\n    }\n\n    return {\n      value: {'spectrogram': spectrogramTensor, 'waveform': waveformTensor},\n      done: false\n    };\n  }\n\n  // Capture one result from the audio stream, and extract the value from\n  // iterator.next() result.\n  async capture(): Promise<{spectrogram: Tensor3D, waveform: Tensor2D}> {\n    return (await this.next()).value as\n        {spectrogram: Tensor3D, waveform: Tensor2D};\n  }\n\n  private async getAudioData():\n      Promise<{freqDataQueue: Float32Array[], timeDataQueue: Float32Array[]}> {\n    const freqDataQueue: Float32Array[] = [];\n    const timeDataQueue: Float32Array[] = [];\n    let currentFrames = 0;\n    return new Promise(resolve => {\n      const intervalID = setInterval(() => {\n        if (this.includeSpectrogram) {\n          this.analyser.getFloatFrequencyData(this.freqData);\n          // If the audio stream is initializing, return empty queue.\n          if (this.freqData[0] === -Infinity) {\n            resolve({freqDataQueue, timeDataQueue});\n          }\n          freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n        }\n        if (this.includeWaveform) {\n          this.analyser.getFloatTimeDomainData(this.timeData);\n          timeDataQueue.push(this.timeData.slice());\n        }\n\n        // Clean interval and return when all frames have been collected\n        if (++currentFrames === this.numFrames) {\n          clearInterval(intervalID);\n          resolve({freqDataQueue, timeDataQueue});\n        }\n      }, this.fftSize / this.sampleRateHz * 1e3);\n    });\n  }\n\n  // Stop the audio stream and pause the iterator.\n  stop(): void {\n    if (!this.isClosed) {\n      this.isClosed = true;\n      this.analyser.disconnect();\n      this.audioContext.close();\n      if (this.stream != null && this.stream.getTracks().length > 0) {\n        this.stream.getTracks()[0].stop();\n      }\n    }\n  }\n\n  // Override toArray() function to prevent collecting.\n  toArray(): Promise<Tensor[]> {\n    throw new Error('Can not convert infinite audio stream to array.');\n  }\n\n  // Return audio sampling rate in Hz\n  getSampleRate(): number {\n    return this.sampleRateHz;\n  }\n\n  private flattenQueue(queue: Float32Array[]): Float32Array {\n    const frameSize = queue[0].length;\n    const freqData = new Float32Array(queue.length * frameSize);\n    queue.forEach((data, i) => freqData.set(data, i * frameSize));\n    return freqData;\n  }\n\n  private getTensorFromAudioDataArray(freqData: Float32Array, shape: number[]):\n      Tensor {\n    const vals = new Float32Array(util.sizeFromShape(shape));\n    // If the data is less than the output shape, the rest is padded with zeros.\n    vals.set(freqData, vals.length - freqData.length);\n    return tensor(vals, shape);\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {browser, cast, env, expandDims, image, reshape, tensor1d, Tensor1D, tensor2d, Tensor2D, Tensor3D, Tensor4D, tidy, util} from '@tensorflow/tfjs-core';\nimport {WebcamConfig} from '../types';\nimport {LazyIterator} from './lazy_iterator';\n\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\nexport class WebcamIterator extends LazyIterator<Tensor3D> {\n  private isClosed = true;\n  private stream: MediaStream;\n  private resize = false;\n  private cropSize: [number, number];\n  private cropBox: Tensor2D;\n  private cropBoxInd: Tensor1D;\n\n  private constructor(\n      protected readonly webcamVideoElement: HTMLVideoElement,\n      protected readonly webcamConfig: WebcamConfig) {\n    super();\n    if (this.needToResize()) {\n      this.resize = true;\n      this.cropSize =\n          [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n      this.cropBoxInd = tensor1d([0], 'int32');\n      if (this.webcamConfig.centerCrop) {\n        // Calculate the box based on resizing shape.\n        const widthCroppingRatio =\n            this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n        const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 /\n            this.webcamVideoElement.height;\n        const widthCropStart = (1 - widthCroppingRatio) / 2;\n        const heightCropStart = (1 - heightCroppingRatio) / 2;\n        const widthCropEnd = widthCropStart + widthCroppingRatio;\n        const heightCropEnd = heightCroppingRatio + heightCropStart;\n        this.cropBox = tensor2d(\n            [heightCropStart, widthCropStart, heightCropEnd, widthCropEnd],\n            [1, 4]);\n      } else {\n        this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n      }\n    }\n  }\n\n  summary() {\n    return `webcam`;\n  }\n\n  // Construct a WebcamIterator and start it's video stream.\n  static async create(\n      webcamVideoElement?: HTMLVideoElement, webcamConfig: WebcamConfig = {}) {\n    if (!env().get('IS_BROWSER')) {\n      throw new Error(\n          'tf.data.webcam is only supported in browser environment.');\n    }\n\n    if (!webcamVideoElement) {\n      // If webcam video element is not provided, create a hidden video element\n      // with provided width and height.\n      webcamVideoElement = document.createElement('video');\n      if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n        throw new Error(\n            'Please provide webcam video element, or resizeWidth and ' +\n            'resizeHeight to create a hidden video element.');\n      }\n      webcamVideoElement.width = webcamConfig.resizeWidth;\n      webcamVideoElement.height = webcamConfig.resizeHeight;\n    }\n    const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig);\n\n    // Call async function to initialize the video stream.\n    await webcamIterator.start();\n\n    return webcamIterator;\n  }\n\n  // Async function to start video stream.\n  async start(): Promise<void> {\n    if (this.webcamConfig.facingMode) {\n      util.assert(\n          (this.webcamConfig.facingMode === 'user') ||\n              (this.webcamConfig.facingMode === 'environment'),\n          () =>\n              `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. ` +\n              `Please provide 'user' or 'environment'`);\n    }\n\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          deviceId: this.webcamConfig.deviceId,\n          facingMode: this.webcamConfig.facingMode ?\n              this.webcamConfig.facingMode :\n              'user',\n          width: this.webcamVideoElement.width,\n          height: this.webcamVideoElement.height\n        }\n      });\n    } catch (e) {\n      // Modify the error message but leave the stack trace intact\n      e.message = `Error thrown while initializing video stream: ${e.message}`;\n      throw e;\n    }\n\n    if (!this.stream) {\n      throw new Error('Could not obtain video from webcam.');\n    }\n\n    // Older browsers may not have srcObject\n    try {\n      this.webcamVideoElement.srcObject = this.stream;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n    }\n    // Start the webcam video stream\n    this.webcamVideoElement.play();\n\n    this.isClosed = false;\n\n    return new Promise<void>(resolve => {\n      // Add event listener to make sure the webcam has been fully initialized.\n      this.webcamVideoElement.onloadedmetadata = () => {\n        resolve();\n      };\n    });\n  }\n\n  async next(): Promise<IteratorResult<Tensor3D>> {\n    if (this.isClosed) {\n      return {value: null, done: true};\n    }\n\n    let img;\n    try {\n      img = browser.fromPixels(this.webcamVideoElement);\n    } catch (e) {\n      throw new Error(\n          `Error thrown converting video to pixels: ${JSON.stringify(e)}`);\n    }\n    if (this.resize) {\n      try {\n        return {value: this.cropAndResizeFrame(img), done: false};\n      } catch (e) {\n        throw new Error(`Error thrown cropping the video: ${e.message}`);\n      } finally {\n        img.dispose();\n      }\n    } else {\n      return {value: img, done: false};\n    }\n  }\n\n  private needToResize() {\n    // If resizeWidth and resizeHeight are provided, and different from the\n    // width and height of original HTMLVideoElement, then resizing and cropping\n    // is required.\n    if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight &&\n        (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth ||\n         this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n      return true;\n    }\n    return false;\n  }\n\n  // Cropping and resizing each frame based on config\n  cropAndResizeFrame(img: Tensor3D): Tensor3D {\n    return tidy(() => {\n      const expandedImage: Tensor4D = expandDims(cast(img, 'float32'), (0));\n      let resizedImage;\n      resizedImage = image.cropAndResize(\n          expandedImage, this.cropBox, this.cropBoxInd, this.cropSize,\n          'bilinear');\n      // Extract image from batch cropping.\n      const shape = resizedImage.shape;\n      return reshape(resizedImage, shape.slice(1) as [number, number, number]);\n    });\n  }\n\n  // Capture one frame from the video stream, and extract the value from\n  // iterator.next() result.\n  async capture(): Promise<Tensor3D> {\n    return (await this.next()).value;\n  }\n\n  // Stop the video stream and pause webcam iterator.\n  stop(): void {\n    const tracks = this.stream.getTracks();\n\n    tracks.forEach(track => track.stop());\n\n    try {\n      this.webcamVideoElement.srcObject = null;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = null;\n    }\n    this.isClosed = true;\n  }\n\n  // Override toArray() function to prevent collecting.\n  toArray(): Promise<Tensor3D[]> {\n    throw new Error('Can not convert infinite video stream to array.');\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {ByteChunkIterator} from './iterators/byte_chunk_iterator';\n\n/**\n * Represents a data source readable as a stream of binary data chunks.\n *\n * Because `Dataset`s can be read repeatedly (via `Dataset.iterator()`), this\n * provides a means to repeatedly create streams from the underlying data\n * sources.\n */\nexport abstract class DataSource {\n  /**\n   * Obtain a new stream of binary data chunks.\n   *\n   * Starts the new stream from the beginning of the data source, even if other\n   * streams have been obtained previously.\n   */\n  abstract async iterator(): Promise<ByteChunkIterator>;\n\n  // TODO(soergel): consider chainable Dataset construction here\n}\n\n// TODO(soergel): consider convenience factory functions here\n// in combination with chainable source->dataset above, e.g.:\n// tf.data.url(...).asCsvDataset().shuffle().batch()\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {LazyIterator, OneToManyIterator} from './lazy_iterator';\n\nexport abstract class StringIterator extends LazyIterator<string> {\n  /**\n   * Splits a string stream on a given separator.\n   *\n   * It is assumed that the incoming chunk boundaries have no semantic meaning,\n   * so conceptually the incoming stream is treated simply as the concatenation\n   * of its elements.\n   *\n   * The outgoing stream provides chunks corresponding to the results of the\n   * standard string split() operation (even if such a chunk spanned incoming\n   * chunks).  The separators are not included.\n   *\n   * A typical usage is to split a text file (represented as a stream with\n   * arbitrary chunk boundaries) into lines.\n   *\n   * @param upstream A readable stream of strings that can be treated as\n   *   concatenated.\n   * @param separator A character to split on.\n   */\n  split(separator: string): StringIterator {\n    return new SplitIterator(this, separator);\n  }\n}\n\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on StringIterator.  Unfortunately they can't be placed in separate files, due\n// to resulting trouble with circular imports.\n// ============================================================================\n\n// We wanted multiple inheritance, e.g.\n//   class SplitIterator extends QueueIterator<string>, StringIterator\n// but the TypeScript mixin approach is a bit hacky, so we take this adapter\n// approach instead.\n\nclass SplitIterator extends StringIterator {\n  private impl: SplitIteratorImpl;\n\n  constructor(protected upstream: LazyIterator<string>, separator: string) {\n    super();\n    this.impl = new SplitIteratorImpl(upstream, separator);\n  }\n\n  summary() {\n    return this.impl.summary();\n  }\n\n  async next() {\n    return this.impl.next();\n  }\n}\n\nclass SplitIteratorImpl extends OneToManyIterator<string> {\n  // A partial string at the end of an upstream chunk\n  carryover = '';\n\n  constructor(\n      protected upstream: LazyIterator<string>, protected separator: string) {\n    super();\n  }\n\n  summary() {\n    return `${this.upstream.summary()} -> Split('${this.separator}')`;\n  }\n\n  async pump(): Promise<boolean> {\n    const chunkResult = await this.upstream.next();\n    if (chunkResult.done) {\n      if (this.carryover === '') {\n        return false;\n      }\n\n      // Pretend that the pump succeeded in order to emit the small last batch.\n      // The next pump() call will actually fail.\n      this.outputQueue.push(this.carryover);\n      this.carryover = '';\n      return true;\n    }\n    const lines = chunkResult.value.split(this.separator);\n    // Note the behavior: \" ab \".split(' ') === ['', 'ab', '']\n    // Thus the carryover may be '' if the separator falls on a chunk\n    // boundary; this produces the correct result.\n\n    lines[0] = this.carryover + lines[0];\n    for (const line of lines.slice(0, -1)) {\n      this.outputQueue.push(line);\n    }\n    this.carryover = lines[lines.length - 1];\n\n    return true;\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\nimport {LazyIterator, OneToManyIterator} from './lazy_iterator';\nimport {StringIterator} from './string_iterator';\n\nexport abstract class ByteChunkIterator extends LazyIterator<Uint8Array> {\n  /**\n   * Decode a stream of UTF8-encoded byte arrays to a stream of strings.\n   *\n   * The byte arrays producetd from the ByteChunkIterator on which this is\n   * called will be interpreted as concatenated.  No assumptions are made about\n   * the boundaries of the incoming chunks, so a multi-byte UTF8 encoding of a\n   * character may span the boundary between chunks.  This naturally happens,\n   * for instance, when reading fixed-size byte arrays from a file.\n   */\n  decodeUTF8(): StringIterator {\n    return new Utf8Iterator(this);\n  }\n}\n\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on ByteChunkIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n\n// We wanted multiple inheritance, e.g.\n//   class Utf8Iterator extends QueueIterator<string>, StringIterator\n// but the TypeScript mixin approach is a bit hacky, so we take this adapter\n// approach instead.\n\nclass Utf8Iterator extends StringIterator {\n  private impl: Utf8IteratorImpl;\n\n  constructor(protected upstream: LazyIterator<Uint8Array>) {\n    super();\n    this.impl = new Utf8IteratorImpl(upstream);\n  }\n\n  summary() {\n    return this.impl.summary();\n  }\n\n  async next() {\n    return this.impl.next();\n  }\n}\n\n/**\n * Decode a stream of UTF8-encoded byte arrays to a stream of strings.\n *\n * This is tricky because the incoming byte array boundaries may disrupt a\n * multi-byte UTF8 character. Thus any incomplete character data at the end of\n * a chunk must be carried over and prepended to the next chunk before\n * decoding. Luckily with native decoder, TextDecoder in browser and\n * string_decoder in node, byte array boundaries are handled automatically.\n *\n * In the context of an input pipeline for machine learning, UTF8 decoding is\n * needed to parse text files containing training examples or prediction\n * requests (e.g., formatted as CSV or JSON). We cannot use the built-in\n * decoding provided by FileReader.readAsText() because here we are in a\n * streaming context, which FileReader does not support.\n *\n * @param upstream A `LazyIterator` of `Uint8Arrays` containing UTF8-encoded\n *   text, which should be interpreted as concatenated.  No assumptions are\n *   made about the boundaries of the incoming chunks, so a multi-byte UTF8\n *   encoding of a character may span the boundary between chunks.  This\n *   naturally happens, for instance, when reading fixed-size byte arrays from a\n *   file.\n */\nclass Utf8IteratorImpl extends OneToManyIterator<string> {\n  // `decoder` as `any` here to dynamically assign value based on the\n  // environment.\n  // tslint:disable-next-line:no-any\n  decoder: any;\n\n  constructor(protected readonly upstream: LazyIterator<Uint8Array>) {\n    super();\n    if (env().get('IS_BROWSER')) {\n      this.decoder = new TextDecoder('utf-8');\n    } else {\n      // tslint:disable-next-line:no-require-imports\n      const {StringDecoder} = require('string_decoder');\n      this.decoder = new StringDecoder('utf8');\n    }\n  }\n  summary() {\n    return `${this.upstream.summary()} -> Utf8`;\n  }\n\n  async pump(): Promise<boolean> {\n    const chunkResult = await this.upstream.next();\n    let chunk;\n    if (chunkResult.done) {\n      return false;\n    } else {\n      chunk = chunkResult.value;\n    }\n\n    let text: string;\n    if (env().get('IS_BROWSER')) {\n      text = this.decoder.decode(chunk, {stream: true});\n    } else {\n      text = this.decoder.write(Buffer.from(chunk.buffer));\n    }\n    this.outputQueue.push(text);\n    return true;\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\n// inspired by https://github.com/maxogden/filereader-stream\nimport {env, util} from '@tensorflow/tfjs-core';\nimport {FileElement} from '../types';\nimport {ByteChunkIterator} from './byte_chunk_iterator';\n\nexport interface FileChunkIteratorOptions {\n  /** The byte offset at which to begin reading the File or Blob. Default 0. */\n  offset?: number;\n  /** The number of bytes to read at a time. Default 1MB. */\n  chunkSize?: number;\n}\n\n/**\n * Provide a stream of chunks from a File, Blob, or Uint8Array.\n * @param file The source File, Blob or Uint8Array.\n * @param options Optional settings controlling file reading.\n * @returns a lazy Iterator of Uint8Arrays containing sequential chunks of the\n *   input File, Blob or Uint8Array.\n */\nexport class FileChunkIterator extends ByteChunkIterator {\n  offset: number;\n  chunkSize: number;\n\n  constructor(\n      protected file: FileElement,\n      protected options: FileChunkIteratorOptions = {}) {\n    super();\n    util.assert(\n        (file instanceof Uint8Array) ||\n            (env().get('IS_BROWSER') ?\n                 (file instanceof File || file instanceof Blob) :\n                 false),\n        () => 'FileChunkIterator only supports File, Blob and Uint8Array ' +\n            'right now.');\n    this.offset = options.offset || 0;\n    // default 1MB chunk has tolerable perf on large files\n    this.chunkSize = options.chunkSize || 1024 * 1024;\n  }\n\n  summary() {\n    return `FileChunks ${this.file}`;\n  }\n\n  async next(): Promise<IteratorResult<Uint8Array>> {\n    if (this.offset >= ((this.file instanceof Uint8Array) ?\n                            this.file.byteLength :\n                            this.file.size)) {\n      return {value: null, done: true};\n    }\n    const chunk = new Promise<Uint8Array>((resolve, reject) => {\n      const end = this.offset + this.chunkSize;\n      if (this.file instanceof Uint8Array) {\n        // Note if end > this.uint8Array.byteLength, we just get a small last\n        // chunk.\n        resolve(new Uint8Array(this.file.slice(this.offset, end)));\n      } else {\n        // This branch assumes that this.file type is File or Blob, which\n        // means it is in the browser environment.\n\n        // TODO(soergel): is this a performance issue?\n        const fileReader = new FileReader();\n        fileReader.onload = (event) => {\n          let data: string|ArrayBuffer|Uint8Array = fileReader.result;\n          // Not sure we can trust the return type of\n          // FileReader.readAsArrayBuffer See e.g.\n          // https://github.com/node-file-api/FileReader/issues/2\n          if (data instanceof ArrayBuffer) {\n            data = new Uint8Array(data);\n          }\n          if (!(data instanceof Uint8Array)) {\n            return reject(new TypeError('FileReader returned unknown type.'));\n          }\n          resolve(data);\n        };\n        fileReader.onabort = (event) => {\n          return reject(new Error('Aborted'));\n        };\n        fileReader.onerror = (event) => {\n          return reject(new Error(event.type));\n        };\n        // TODO(soergel): better handle onabort, onerror\n        // Note if end > this.file.size, we just get a small last chunk.\n        const slice = this.file.slice(this.offset, end);\n        // We can't use readAsText here (even if we know the file is text)\n        // because the slice boundary may fall within a multi-byte character.\n        fileReader.readAsArrayBuffer(slice);\n      }\n      this.offset = end;\n    });\n    return {value: (await chunk), done: false};\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\nimport {FileChunkIterator, FileChunkIteratorOptions} from './file_chunk_iterator';\n\n/**\n * Provide a stream of chunks from a URL.\n *\n * Note this class first downloads the entire file into memory before providing\n * the first element from the stream.  This is because the Fetch API does not\n * yet reliably provide a reader stream for the response body.\n */\nexport async function urlChunkIterator(\n    url: RequestInfo, options: FileChunkIteratorOptions = {},\n    fetchFunc?: Function) {\n  let urlString;\n  let requestInit;\n  if ((typeof url) === 'string') {\n    urlString = url as string;\n  } else {\n    urlString = (url as Request).url;\n    requestInit = getRequestInitFromRequest(url as Request);\n  }\n  const response = await (fetchFunc || util.fetch)(urlString, requestInit);\n  if (response.ok) {\n    const uint8Array = new Uint8Array(await response.arrayBuffer());\n    return new FileChunkIterator(uint8Array, options);\n  } else {\n    throw new Error(response.statusText);\n  }\n}\n\n// Generate RequestInit from Request to match tf.util.fetch signature.\nconst getRequestInitFromRequest = (request: Request) => {\n  const init = {\n    method: request.method,\n    headers: request.headers,\n    body: request.body,\n    mode: request.mode,\n    credentials: request.credentials,\n    cache: request.cache,\n    redirect: request.redirect,\n    referrer: request.referrer,\n    integrity: request.integrity,\n  };\n  return init;\n};\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\n// Skip tslint any type check cause this method is aiming to check type of\n// input.\n// tslint:disable-next-line:no-any\nexport function isLocalPath(source: any): boolean {\n  return (typeof source === 'string') && source.slice(0, 7) === 'file://';\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\nimport {DataSource} from '../datasource';\nimport {ByteChunkIterator} from '../iterators/byte_chunk_iterator';\nimport {FileChunkIterator, FileChunkIteratorOptions} from '../iterators/file_chunk_iterator';\nimport {FileElement} from '../types';\nimport {isLocalPath} from '../util/source_util';\n\n/**\n * Represents a file, blob, or Uint8Array readable as a stream of binary data\n * chunks.\n */\nexport class FileDataSource extends DataSource {\n  /**\n   * Create a `FileDataSource`.\n   *\n   * @param input Local file path, or `File`/`Blob`/`Uint8Array` object to\n   *     read. Local file only works in node environment.\n   * @param options Options passed to the underlying `FileChunkIterator`s,\n   *   such as {chunksize: 1024}.\n   */\n  constructor(\n      protected input: FileElement|string,\n      protected readonly options: FileChunkIteratorOptions = {}) {\n    super();\n  }\n\n  async iterator(): Promise<ByteChunkIterator> {\n    if (isLocalPath(this.input) && env().get('IS_NODE')) {\n      // tslint:disable-next-line:no-require-imports\n      const fs = require('fs');\n      this.input = fs.readFileSync((this.input as string).slice(7));\n    }\n    // TODO(kangyizhang): Add LocalFileChunkIterator to split local streaming\n    // with file in browser.\n    return new FileChunkIterator(this.input as FileElement, this.options);\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {DataSource} from '../datasource';\nimport {ByteChunkIterator} from '../iterators/byte_chunk_iterator';\nimport {FileChunkIteratorOptions} from '../iterators/file_chunk_iterator';\nimport {urlChunkIterator} from '../iterators/url_chunk_iterator';\nimport {isLocalPath} from '../util/source_util';\nimport {FileDataSource} from './file_data_source';\n\n/*\n * Represents a URL readable as a stream of binary data chunks.\n */\nexport class URLDataSource extends DataSource {\n  /**\n   * Create a `URLDataSource`.\n   *\n   * @param url A source URL string, or a `Request` object.\n   * @param options Options passed to the underlying `FileChunkIterator`s,\n   *   such as {chunksize: 1024}.\n   */\n  constructor(\n      protected readonly url: RequestInfo,\n      protected readonly fileOptions: FileChunkIteratorOptions = {}) {\n    super();\n  }\n\n  // TODO(soergel): provide appropriate caching options.  Currently this\n  // will download the URL anew for each call to iterator().  Since we have\n  // to treat the downloaded file as a blob/buffer anyway, we may as well retain\n  // it-- but that raises GC issues.  Also we may want a persistent disk cache.\n  async iterator(): Promise<ByteChunkIterator> {\n    if (isLocalPath(this.url)) {\n      return (new FileDataSource(this.url as string, this.fileOptions))\n          .iterator();\n    } else {\n      return urlChunkIterator(this.url, this.fileOptions);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {TensorContainer} from '@tensorflow/tfjs-core';\nimport {Dataset, datasetFromIteratorFn} from './dataset';\nimport {CSVDataset} from './datasets/csv_dataset';\nimport {iteratorFromFunction} from './iterators/lazy_iterator';\nimport {MicrophoneIterator} from './iterators/microphone_iterator';\nimport {WebcamIterator} from './iterators/webcam_iterator';\nimport {URLDataSource} from './sources/url_data_source';\nimport {CSVConfig, MicrophoneConfig, WebcamConfig} from './types';\n\n/**\n * Create a `CSVDataset` by reading and decoding CSV file(s) from provided URL\n * or local path if it's in Node environment.\n *\n * Note: If isLabel in columnConfigs is `true` for at least one column, the\n * element in returned `CSVDataset` will be an object of\n * `{xs:features, ys:labels}`: xs is a dict of features key/value pairs, ys\n * is a dict of labels key/value pairs. If no column is marked as label,\n * returns a dict of features only.\n *\n * ```js\n * const csvUrl =\n * 'https://storage.googleapis.com/tfjs-examples/multivariate-linear-regression/data/boston-housing-train.csv';\n *\n * async function run() {\n *   // We want to predict the column \"medv\", which represents a median value of\n *   // a home (in $1000s), so we mark it as a label.\n *   const csvDataset = tf.data.csv(\n *     csvUrl, {\n *       columnConfigs: {\n *         medv: {\n *           isLabel: true\n *         }\n *       }\n *     });\n *\n *   // Number of features is the number of column names minus one for the label\n *   // column.\n *   const numOfFeatures = (await csvDataset.columnNames()).length - 1;\n *\n *   // Prepare the Dataset for training.\n *   const flattenedDataset =\n *     csvDataset\n *     .map(({xs, ys}) =>\n *       {\n *         // Convert xs(features) and ys(labels) from object form (keyed by\n *         // column name) to array form.\n *         return {xs:Object.values(xs), ys:Object.values(ys)};\n *       })\n *     .batch(10);\n *\n *   // Define the model.\n *   const model = tf.sequential();\n *   model.add(tf.layers.dense({\n *     inputShape: [numOfFeatures],\n *     units: 1\n *   }));\n *   model.compile({\n *     optimizer: tf.train.sgd(0.000001),\n *     loss: 'meanSquaredError'\n *   });\n *\n *   // Fit the model using the prepared Dataset\n *   return model.fitDataset(flattenedDataset, {\n *     epochs: 10,\n *     callbacks: {\n *       onEpochEnd: async (epoch, logs) => {\n *         console.log(epoch + ':' + logs.loss);\n *       }\n *     }\n *   });\n * }\n *\n * await run();\n * ```\n *\n * @param source URL or local path to get CSV file. If it's a local path, it\n * must have prefix `file://` and it only works in node environment.\n * @param csvConfig (Optional) A CSVConfig object that contains configurations\n *     of reading and decoding from CSV file(s).\n *\n * @doc {\n *   heading: 'Data',\n *   subheading: 'Creation',\n *   namespace: 'data',\n *   configParamIndices: [1]\n *  }\n */\nexport function csv(\n    source: RequestInfo, csvConfig: CSVConfig = {}): CSVDataset {\n  return new CSVDataset(new URLDataSource(source), csvConfig);\n}\n\n/**\n * Create a `Dataset` that produces each element by calling a provided function.\n *\n * Note that repeated iterations over this `Dataset` may produce different\n * results, because the function will be called anew for each element of each\n * iteration.\n *\n * Also, beware that the sequence of calls to this function may be out of order\n * in time with respect to the logical order of the Dataset. This is due to the\n * asynchronous lazy nature of stream processing, and depends on downstream\n * transformations (e.g. .shuffle()). If the provided function is pure, this is\n * no problem, but if it is a closure over a mutable state (e.g., a traversal\n * pointer), then the order of the produced elements may be scrambled.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const ds = tf.data.func(func);\n * await ds.forEachAsync(e => console.log(e));\n * ```\n *\n * @param f A function that produces one data element on each call.\n */\nexport function func<T extends TensorContainer>(\n    f: () => IteratorResult<T>| Promise<IteratorResult<T>>): Dataset<T> {\n  const iter = iteratorFromFunction(f);\n  return datasetFromIteratorFn(async () => iter);\n}\n\n/**\n * Create a `Dataset` that produces each element from provided JavaScript\n * generator, which is a function*\n * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Generator_functions),\n * or a function that returns an\n * iterator\n * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Generator_functions).\n *\n * The returned iterator should have `.next()` function that returns element in\n * format of `{value: TensorContainer, done:boolean}`.\n *\n * Example of creating a dataset from an iterator factory:\n * ```js\n * function makeIterator() {\n *   const numElements = 10;\n *   let index = 0;\n *\n *   const iterator = {\n *     next: () => {\n *       let result;\n *       if (index < numElements) {\n *         result = {value: index, done: false};\n *         index++;\n *         return result;\n *       }\n *       return {value: index, done: true};\n *     }\n *   };\n *   return iterator;\n * }\n * const ds = tf.data.generator(makeIterator);\n * await ds.forEachAsync(e => console.log(e));\n * ```\n *\n * Example of creating a dataset from a generator:\n * ```js\n * function* dataGenerator() {\n *   const numElements = 10;\n *   let index = 0;\n *   while (index < numElements) {\n *     const x = index;\n *     index++;\n *     yield x;\n *   }\n * }\n *\n * const ds = tf.data.generator(dataGenerator);\n * await ds.forEachAsync(e => console.log(e));\n * ```\n *\n * @param generator A JavaScript generator function that returns a JavaScript\n *     iterator.\n *\n * @doc {\n *   heading: 'Data',\n *   subheading: 'Creation',\n *   namespace: 'data',\n *   configParamIndices: [1]\n *  }\n */\nexport function generator<T extends TensorContainer>(\n    generator: () => Iterator<T>| Promise<Iterator<T>>): Dataset<T> {\n  return datasetFromIteratorFn(async () => {\n    const gen = await generator();\n    return iteratorFromFunction(() => gen.next());\n  });\n}\n\n/**\n * Create an iterator that generates `Tensor`s from webcam video stream. This\n * API only works in Browser environment when the device has webcam.\n *\n * Note: this code snippet only works when the device has a webcam. It will\n * request permission to open the webcam when running.\n * ```js\n * const videoElement = document.createElement('video');\n * videoElement.width = 100;\n * videoElement.height = 100;\n * const cam = await tf.data.webcam(videoElement);\n * const img = await cam.capture();\n * img.print();\n * cam.stop();\n * ```\n *\n * @param webcamVideoElement A `HTMLVideoElement` used to play video from\n *     webcam. If this element is not provided, a hidden `HTMLVideoElement` will\n *     be created. In that case, `resizeWidth` and `resizeHeight` must be\n *     provided to set the generated tensor shape.\n * @param webcamConfig A `WebcamConfig` object that contains configurations of\n *     reading and manipulating data from webcam video stream.\n *\n * @doc {\n *   heading: 'Data',\n *   subheading: 'Creation',\n *   namespace: 'data',\n *   ignoreCI: true\n *  }\n */\nexport async function webcam(\n    webcamVideoElement?: HTMLVideoElement,\n    webcamConfig?: WebcamConfig): Promise<WebcamIterator> {\n  return WebcamIterator.create(webcamVideoElement, webcamConfig);\n}\n\n/**\n * Create an iterator that generates frequency-domain spectrogram `Tensor`s from\n * microphone audio stream with browser's native FFT. This API only works in\n * browser environment when the device has microphone.\n *\n * Note: this code snippet only works when the device has a microphone. It will\n * request permission to open the microphone when running.\n * ```js\n * const mic = await tf.data.microphone({\n *   fftSize: 1024,\n *   columnTruncateLength: 232,\n *   numFramesPerSpectrogram: 43,\n *   sampleRateHz:44100,\n *   includeSpectrogram: true,\n *   includeWaveform: true\n * });\n * const audioData = await mic.capture();\n * const spectrogramTensor = audioData.spectrogram;\n * spectrogramTensor.print();\n * const waveformTensor = audioData.waveform;\n * waveformTensor.print();\n * mic.stop();\n * ```\n *\n * @param microphoneConfig A `MicrophoneConfig` object that contains\n *     configurations of reading audio data from microphone.\n *\n * @doc {\n *   heading: 'Data',\n *   subheading: 'Creation',\n *   namespace: 'data',\n *   ignoreCI: true\n *  }\n */\nexport async function microphone(microphoneConfig?: MicrophoneConfig):\n    Promise<MicrophoneIterator> {\n  return MicrophoneIterator.create(microphoneConfig);\n}\n", "/** @license See the LICENSE file. */\n\n// This code is auto-generated, do not modify this file!\nconst version = '3.21.0';\nexport {version};\n"],
  "mappings": "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",
  "names": ["len", "i", "len2", "Buffer", "array", "i", "byteLength", "Buffer", "Buffer", "dist_exports", "seedrandom", "func", "ZipMismatchMode", "generator"]
}
